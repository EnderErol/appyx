{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Appyx \u00b6 Model-driven navigation for Jetpack Compose https://github.com/bumble-tech/appyx Navigation for your Compose app on steroids \u00b6 Navigate directly from code \u2013 In a type-safe way, without boilerplate Gain control of navigation state \u2013 Making your navigation unit-testable Complete control over operations and behaviour \u2013 Use and extend the back stack or the view pager from the library, or build your own Your own navigation \u2013 With Appyx, you can define your own navigation models Use any animation for transitions \u2013 Anything you can represent with Compose Modifiers Model-driven navigation \u2013 a different paradigm with superpowers \u00b6 Using Appyx you gain navigation superpowers in addition to screen-to-screen navigation: Break down screen boundaries \u2013 Using NavModels you can navigate inside the screen as well as between them Make your navigation composable \u2013 Navigate whole scopes of your application Using a model-driven approach, navigation states are yours to define \u2013 Appyx makes it happen with any animation you can represent using Compose Modifiers . Back stacks, card stacks, view pagers are just the beginning: You can create custom navigable components in no time: With Appyx you can break down screen boundaries and transform the screen itself: See Model-driven navigation for more details. Launch the demo app \u00b6 Check out the project and launch the :app module for a quick demonstration! Download \u00b6 See the Downloads page . Learning Appyx \u00b6 Check out the Quick start guide , Codelabs , and Sample apps ! Articles \u00b6 Appyx is released! (1.0-alpha02) Appyx vs Jetpack Compose Navigation Modelling dating cards navigation with Appyx Videos \u00b6 Model-driven navigation with Jetpack Compose Model-driven navigation with Appyx News & updates \u00b6 See our News & updates page You can also follow some of us tweeting about Appyx on these accounts: @ZsoltKocsi @andreyk_nn","title":"Overview"},{"location":"#appyx","text":"Model-driven navigation for Jetpack Compose https://github.com/bumble-tech/appyx","title":"Appyx"},{"location":"#navigation-for-your-compose-app-on-steroids","text":"Navigate directly from code \u2013 In a type-safe way, without boilerplate Gain control of navigation state \u2013 Making your navigation unit-testable Complete control over operations and behaviour \u2013 Use and extend the back stack or the view pager from the library, or build your own Your own navigation \u2013 With Appyx, you can define your own navigation models Use any animation for transitions \u2013 Anything you can represent with Compose Modifiers","title":"Navigation for your Compose app on steroids"},{"location":"#model-driven-navigation-a-different-paradigm-with-superpowers","text":"Using Appyx you gain navigation superpowers in addition to screen-to-screen navigation: Break down screen boundaries \u2013 Using NavModels you can navigate inside the screen as well as between them Make your navigation composable \u2013 Navigate whole scopes of your application Using a model-driven approach, navigation states are yours to define \u2013 Appyx makes it happen with any animation you can represent using Compose Modifiers . Back stacks, card stacks, view pagers are just the beginning: You can create custom navigable components in no time: With Appyx you can break down screen boundaries and transform the screen itself: See Model-driven navigation for more details.","title":"Model-driven navigation \u2013 a different paradigm with superpowers"},{"location":"#launch-the-demo-app","text":"Check out the project and launch the :app module for a quick demonstration!","title":"Launch the demo app"},{"location":"#download","text":"See the Downloads page .","title":"Download"},{"location":"#learning-appyx","text":"Check out the Quick start guide , Codelabs , and Sample apps !","title":"Learning Appyx"},{"location":"#articles","text":"Appyx is released! (1.0-alpha02) Appyx vs Jetpack Compose Navigation Modelling dating cards navigation with Appyx","title":"Articles"},{"location":"#videos","text":"Model-driven navigation with Jetpack Compose Model-driven navigation with Appyx","title":"Videos"},{"location":"#news-updates","text":"See our News & updates page You can also follow some of us tweeting about Appyx on these accounts: @ZsoltKocsi @andreyk_nn","title":"News &amp; updates"},{"location":"faq/","text":"FAQ \u00b6 Navigation-related \u00b6 Q: How does Appyx relate to Jetpack Compose Navigation? \u00b6 We wrote an article on this: Appyx vs Jetpack Compose Navigation While Appyx represents a different paradigm, it can also co-exist with Jetpack Compose Navigation. This can be helpful if you want to use Appyx for in-screen mechanisms only, or if you plan to migrate gradually. See Sample apps for more details. Q: How does Appyx compare against other navigation solutions? \u00b6 The core concepts of navigation in Appyx differ from most navigation libraries: You don't have a concept of the \"screen\" present in the model You can define your own navigation models On the UI level you can transform what feels like the \"screen\" itself See Model-driven navigation for more details. Q: How can I navigate to a specific part of my Appyx tree? \u00b6 In most cases Implicit navigation can be your primary choice, and you don't need to explicitly specify a remote point in the tree. This is helpful to avoid coupling. For those cases when you can't avoid it, Explicit navigation and Deep linking covers you. Q: What about dialogs & bottom sheets? \u00b6 You can use Appyx in conjunction with Accompanist or any other Compose mechanism. If you wish, you can model your own Modal with Appyx too. We'll add an example soon. Q: Can I have a bottom sheet conditionally? \u00b6 You could use a similar approach as we do with back buttons in SamplesContainerNode you can find in the :app module: store a flag in the NavTarget that can be different per instance. Using Appyx in an app \u00b6 Q: Is it an all or nothing approach? \u00b6 No, you can adopt Appyx gradually: Plug it in to one screen and just utilise its screen transformation capabilities (e.g. Cards ) Plug it in to a few screens and substitute another navigation mechanism with it, such as Jetpack Compose Navigation Q: What architectural patterns can I use? \u00b6 Appyx is agnostic of architectural patterns. You can use any architectural pattern in the Nodes you'd like. You can even use a different one in each. Q: Can I use it with ViewModel? \u00b6 Yes, we'll add an example soon. Q: Can I use it with Hilt? \u00b6 Our draft PR: #115 (Feel free to provide feedback!) https://github.com/jbreitfeller-sfix/appyx-playground another approach on this topic Performance-related \u00b6 Q: Are Nodes kept alive? \u00b6 In short: you can decide whether a Node : is on-screen is off-screen but kept alive is off-screen and becomes destroyed Check the Lifecycle for more details. On the project itself \u00b6 Q: Is it production ready? \u00b6 Yes, Appyx matured to its stable version. We also use it at Bumble in production, and as such, we're committed to maintaining and improving it. Q: What's your roadmap? \u00b6 We're full with ideas where to take Appyx further! A more detailed roadmap will be added later. Come back for more updates. Other \u00b6 Have a question? Raise it in Discussions !.","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#navigation-related","text":"","title":"Navigation-related"},{"location":"faq/#q-how-does-appyx-relate-to-jetpack-compose-navigation","text":"We wrote an article on this: Appyx vs Jetpack Compose Navigation While Appyx represents a different paradigm, it can also co-exist with Jetpack Compose Navigation. This can be helpful if you want to use Appyx for in-screen mechanisms only, or if you plan to migrate gradually. See Sample apps for more details.","title":"Q: How does Appyx relate to Jetpack Compose Navigation?"},{"location":"faq/#q-how-does-appyx-compare-against-other-navigation-solutions","text":"The core concepts of navigation in Appyx differ from most navigation libraries: You don't have a concept of the \"screen\" present in the model You can define your own navigation models On the UI level you can transform what feels like the \"screen\" itself See Model-driven navigation for more details.","title":"Q: How does Appyx compare against other navigation solutions?"},{"location":"faq/#q-how-can-i-navigate-to-a-specific-part-of-my-appyx-tree","text":"In most cases Implicit navigation can be your primary choice, and you don't need to explicitly specify a remote point in the tree. This is helpful to avoid coupling. For those cases when you can't avoid it, Explicit navigation and Deep linking covers you.","title":"Q: How can I navigate to a specific part of my Appyx tree?"},{"location":"faq/#q-what-about-dialogs-bottom-sheets","text":"You can use Appyx in conjunction with Accompanist or any other Compose mechanism. If you wish, you can model your own Modal with Appyx too. We'll add an example soon.","title":"Q: What about dialogs &amp; bottom sheets?"},{"location":"faq/#q-can-i-have-a-bottom-sheet-conditionally","text":"You could use a similar approach as we do with back buttons in SamplesContainerNode you can find in the :app module: store a flag in the NavTarget that can be different per instance.","title":"Q: Can I have a bottom sheet conditionally?"},{"location":"faq/#using-appyx-in-an-app","text":"","title":"Using Appyx in an app"},{"location":"faq/#q-is-it-an-all-or-nothing-approach","text":"No, you can adopt Appyx gradually: Plug it in to one screen and just utilise its screen transformation capabilities (e.g. Cards ) Plug it in to a few screens and substitute another navigation mechanism with it, such as Jetpack Compose Navigation","title":"Q: Is it an all or nothing approach?"},{"location":"faq/#q-what-architectural-patterns-can-i-use","text":"Appyx is agnostic of architectural patterns. You can use any architectural pattern in the Nodes you'd like. You can even use a different one in each.","title":"Q: What architectural patterns can I use?"},{"location":"faq/#q-can-i-use-it-with-viewmodel","text":"Yes, we'll add an example soon.","title":"Q: Can I use it with ViewModel?"},{"location":"faq/#q-can-i-use-it-with-hilt","text":"Our draft PR: #115 (Feel free to provide feedback!) https://github.com/jbreitfeller-sfix/appyx-playground another approach on this topic","title":"Q: Can I use it with Hilt?"},{"location":"faq/#performance-related","text":"","title":"Performance-related"},{"location":"faq/#q-are-nodes-kept-alive","text":"In short: you can decide whether a Node : is on-screen is off-screen but kept alive is off-screen and becomes destroyed Check the Lifecycle for more details.","title":"Q: Are Nodes kept alive?"},{"location":"faq/#on-the-project-itself","text":"","title":"On the project itself"},{"location":"faq/#q-is-it-production-ready","text":"Yes, Appyx matured to its stable version. We also use it at Bumble in production, and as such, we're committed to maintaining and improving it.","title":"Q: Is it production ready?"},{"location":"faq/#q-whats-your-roadmap","text":"We're full with ideas where to take Appyx further! A more detailed roadmap will be added later. Come back for more updates.","title":"Q: What's your roadmap?"},{"location":"faq/#other","text":"Have a question? Raise it in Discussions !.","title":"Other"},{"location":"news/","text":"News & updates \u00b6 This section contains noteworthy updates related to the project and the project page. For a detailed list of changes to the codebase, check Changelog . 28 Nov 2022 \u00b6 Added Coding challenges Updated Transitions 21 Nov 2022 \u00b6 FAQ received a major update 31 Oct 2022 \u00b6 \ud83c\udf89 Released 1.0.0 \ud83c\udf89 27-28 Oct 2022 \u00b6 Model-driven navigation with Appyx 22 Sep 2022 \u00b6 Added documentation on ChildAware API . You can use it to scope communication with (or between) dynamically available child nodes easily. 1-2 Sep 2022 \u00b6 Model-driven navigation with Jetpack Compose","title":"News & updates"},{"location":"news/#news-updates","text":"This section contains noteworthy updates related to the project and the project page. For a detailed list of changes to the codebase, check Changelog .","title":"News &amp; updates"},{"location":"news/#28-nov-2022","text":"Added Coding challenges Updated Transitions","title":"28 Nov 2022"},{"location":"news/#21-nov-2022","text":"FAQ received a major update","title":"21 Nov 2022"},{"location":"news/#31-oct-2022","text":"\ud83c\udf89 Released 1.0.0 \ud83c\udf89","title":"31 Oct 2022"},{"location":"news/#27-28-oct-2022","text":"Model-driven navigation with Appyx","title":"27-28 Oct 2022"},{"location":"news/#22-sep-2022","text":"Added documentation on ChildAware API . You can use it to scope communication with (or between) dynamically available child nodes easily.","title":"22 Sep 2022"},{"location":"news/#1-2-sep-2022","text":"Model-driven navigation with Jetpack Compose","title":"1-2 Sep 2022"},{"location":"apps/childaware/","text":"ChildAware API \u00b6 The framework includes the ChildAware interface which comes with a powerful API. It allows you to scope communication with (or between) dynamically available child nodes easily. Baseline \u00b6 In the next examples: Let's assume that SomeNode can host multiple child nodes: Child1 , Child2 , etc. SomeInteractor belongs to SomeNode and is passed as a Plugin to it SomeInteractor extends the Interactor helper class from the framework: It implements NodeLifecycleAware , which makes sure it will receive the onCreate callback from the framework It implements ChildAware , which unlocks the DSL we'll see in the following snippets Single child scenario \u00b6 import androidx.lifecycle.Lifecycle import com.bumble.appyx.core.children.whenChildAttached import com.bumble.appyx.core.children.whenChildrenAttached import com.bumble.appyx.core.clienthelper.interactor.Interactor class SomeInteractor : Interactor < SomeNode > () { override fun onCreate ( lifecycle : Lifecycle ) { lifecycle . subscribe ( onCreate = { // This lambda is executed every time a node of type Child1Node is attached: whenChildAttached { commonLifecycle : Lifecycle , child1 : Child1Node -> // TODO: // - establish communication with child1 // - use commonLifecycle for scoping // - it will be capped by the lifecycles of child1 and the parent } }) } } Multiple children \u00b6 import androidx.lifecycle.Lifecycle import com.bumble.appyx.core.children.whenChildAttached import com.bumble.appyx.core.children.whenChildrenAttached import com.bumble.appyx.core.clienthelper.interactor.Interactor class SomeInteractor : Interactor < SomeNode > () { override fun onCreate ( lifecycle : Lifecycle ) { lifecycle . subscribe ( onCreate = { // This lambda is executed every time these two nodes are attached at the same time: whenChildrenAttached { commonLifecycle : Lifecycle , child1 : Child1Node , child2 : Child2Node -> // TODO // - establish communication between child1 & child2 // - use commonLifecycle for scoping // - it will be capped by the lifecycles of child1, child2 and the parent } }) } }","title":"ChildAware API"},{"location":"apps/childaware/#childaware-api","text":"The framework includes the ChildAware interface which comes with a powerful API. It allows you to scope communication with (or between) dynamically available child nodes easily.","title":"ChildAware API"},{"location":"apps/childaware/#baseline","text":"In the next examples: Let's assume that SomeNode can host multiple child nodes: Child1 , Child2 , etc. SomeInteractor belongs to SomeNode and is passed as a Plugin to it SomeInteractor extends the Interactor helper class from the framework: It implements NodeLifecycleAware , which makes sure it will receive the onCreate callback from the framework It implements ChildAware , which unlocks the DSL we'll see in the following snippets","title":"Baseline"},{"location":"apps/childaware/#single-child-scenario","text":"import androidx.lifecycle.Lifecycle import com.bumble.appyx.core.children.whenChildAttached import com.bumble.appyx.core.children.whenChildrenAttached import com.bumble.appyx.core.clienthelper.interactor.Interactor class SomeInteractor : Interactor < SomeNode > () { override fun onCreate ( lifecycle : Lifecycle ) { lifecycle . subscribe ( onCreate = { // This lambda is executed every time a node of type Child1Node is attached: whenChildAttached { commonLifecycle : Lifecycle , child1 : Child1Node -> // TODO: // - establish communication with child1 // - use commonLifecycle for scoping // - it will be capped by the lifecycles of child1 and the parent } }) } }","title":"Single child scenario"},{"location":"apps/childaware/#multiple-children","text":"import androidx.lifecycle.Lifecycle import com.bumble.appyx.core.children.whenChildAttached import com.bumble.appyx.core.children.whenChildrenAttached import com.bumble.appyx.core.clienthelper.interactor.Interactor class SomeInteractor : Interactor < SomeNode > () { override fun onCreate ( lifecycle : Lifecycle ) { lifecycle . subscribe ( onCreate = { // This lambda is executed every time these two nodes are attached at the same time: whenChildrenAttached { commonLifecycle : Lifecycle , child1 : Child1Node , child2 : Child2Node -> // TODO // - establish communication between child1 & child2 // - use commonLifecycle for scoping // - it will be capped by the lifecycles of child1, child2 and the parent } }) } }","title":"Multiple children"},{"location":"apps/lifecycle/","text":"Lifecycle \u00b6 Nodes have their own lifecycles, directly using the related classes of androidx.lifecycle . Capping \u00b6 No node can be in a higher lifecycle state than any of its parents or the Android Activity it lives in. On-screen & off-screen \u00b6 NavModel controls which children should be rendered on the screen and which should not with NavModel.screenState . The behaviour is customisable in BaseNavModel via OnScreenStateResolver . When a NavElement of the node is marked as on-screen, its lifecycle follows the parent node's lifecycle. The rendering status does not affect it \u2013 the node might not be added to Compose view and still be in a RESUMED state. When a NavElement of the node is marked as off-screen, the following might happen: Its lifecycle is capped with CREATED (or STOPPED ) in case of ChildEntry.KeepMode.KEEP . The node is destroyed and its state is saved in case of ChildEntry.KeepMode.SUSPEND . ChildEntry.KeepMode settings can be configured for each ParentNode individually or globally via Appyx.defaultChildKeepMode . When a node is removed completely from NavModel , it will be in DESTROYED state. Lifecycle changes \u00b6 The lifecycle state can be affected by: The NavModel of the parent (adding or removing child Nodes and changing their on-screen status) The parent's lifecycle state capping its children (transitive in the tree) Android lifecycle (Activity) capping the whole tree Back stack node lifecycle \u00b6 An example demonstrating the above: Note that NavModels might have their slight differences (e.g. whether their operations remove a Node only from the view, or completely destroy it). In the case of the back stack: The Push operation adds a new element and stashes the currently active one \u2013 the stashed one will be removed from the view & STOPPED The Pop operation removes an element, the child Node will be DESTROYED","title":"Lifecycle"},{"location":"apps/lifecycle/#lifecycle","text":"Nodes have their own lifecycles, directly using the related classes of androidx.lifecycle .","title":"Lifecycle"},{"location":"apps/lifecycle/#capping","text":"No node can be in a higher lifecycle state than any of its parents or the Android Activity it lives in.","title":"Capping"},{"location":"apps/lifecycle/#on-screen-off-screen","text":"NavModel controls which children should be rendered on the screen and which should not with NavModel.screenState . The behaviour is customisable in BaseNavModel via OnScreenStateResolver . When a NavElement of the node is marked as on-screen, its lifecycle follows the parent node's lifecycle. The rendering status does not affect it \u2013 the node might not be added to Compose view and still be in a RESUMED state. When a NavElement of the node is marked as off-screen, the following might happen: Its lifecycle is capped with CREATED (or STOPPED ) in case of ChildEntry.KeepMode.KEEP . The node is destroyed and its state is saved in case of ChildEntry.KeepMode.SUSPEND . ChildEntry.KeepMode settings can be configured for each ParentNode individually or globally via Appyx.defaultChildKeepMode . When a node is removed completely from NavModel , it will be in DESTROYED state.","title":"On-screen &amp; off-screen"},{"location":"apps/lifecycle/#lifecycle-changes","text":"The lifecycle state can be affected by: The NavModel of the parent (adding or removing child Nodes and changing their on-screen status) The parent's lifecycle state capping its children (transitive in the tree) Android lifecycle (Activity) capping the whole tree","title":"Lifecycle changes"},{"location":"apps/lifecycle/#back-stack-node-lifecycle","text":"An example demonstrating the above: Note that NavModels might have their slight differences (e.g. whether their operations remove a Node only from the view, or completely destroy it). In the case of the back stack: The Push operation adds a new element and stashes the currently active one \u2013 the stashed one will be removed from the view & STOPPED The Pop operation removes an element, the child Node will be DESTROYED","title":"Back stack node lifecycle"},{"location":"apps/plugins/","text":"Plugins \u00b6 Keeping extra concerns out of Node \u00b6 Nodes are meant to be simple structural elements, and should be kept lean. To keep the framework agnostic of any specific approach / pattern you want to use, there aren't any fixed parts. Rather, the Node offers an extension point using Plugins in its constructor: abstract class Node ( buildContext : BuildContext , val view : NodeView = EmptyNodeView , plugins : List < Plugin > = emptyList () // <-- ) So what is a Plugin ? A Plugin is an empty interface extended by many actual ones: interface Plugin Plugins \u00b6 Lifecycle-related plugins \u00b6 interface NodeLifecycleAware : Plugin { fun onCreate ( lifecycle : Lifecycle ) {} } fun interface Destroyable : Plugin { fun destroy () } Component level plugins \u00b6 Sometimes you need to grab a reference to the component as a whole, either as an interface, or its implementation, the Node . This will come especially handy when working with workflows. interface NodeAware : Plugin { val node : Node <*> fun init ( node : Node <*> ) {} } There are helper classes found in the library, so you don't have to implement the above interfaces, you can just use delegation: class SomeClass ( private val nodeAware : NodeAware = NodeAwareImpl () ) : NodeAware by nodeAware { fun foo () { // [node] is an automatically available property coming from the NodeAware interface // the reference is automatically set for you by the framework + the NodeAwareImpl class // so you can use it right away: node . doSomething () } } \u26a0\ufe0f Note: the reference to node is set by Node automatically, and isn't available immediately after constructing your object, but only after the construction of the Node itself. Navigation plugins \u00b6 In case if you need to control navigation behaviour, you can use these plugins: interface UpNavigationHandler : Plugin { fun handleUpNavigation (): Boolean = false } interface BackPressHandler : Plugin { val onBackPressedCallback : OnBackPressedCallback? get () = null } UpNavigationHandler controls Node.navigateUp behaviour and allows to intercept its invocation. BackPressHandler controls device back press behaviour via androidx.activity.OnBackPressedCallback . You can read more about it here . \u26a0\ufe0f Note: OnBackPressedCallback are invoked in the following order: 1. From children to parents. Render order of children matters! The last rendered child will be the first to handle back press. 2. Direct order of plugins within a node. Plugins are invoked in order they appears in Node(plugins = ...) before the NavModel. Using Plugins \u00b6 All plugins are designed to have empty {} default implementations (or other sensible defaults when a return value is defined), so it's convenient to implement them only if you need. Don't forget to pass your Plugins to your Node : internal class MyNode ( // ... plugins : List < Plugins > = emptyList () // ... ) : Node < Nothing > ( // ... plugins = plugins // ... ) \u26a0\ufe0f Note: plugins is a List , as the order matters here. All Plugin instances are invoked in the order they appear in the list.","title":"Plugins"},{"location":"apps/plugins/#plugins","text":"","title":"Plugins"},{"location":"apps/plugins/#keeping-extra-concerns-out-of-node","text":"Nodes are meant to be simple structural elements, and should be kept lean. To keep the framework agnostic of any specific approach / pattern you want to use, there aren't any fixed parts. Rather, the Node offers an extension point using Plugins in its constructor: abstract class Node ( buildContext : BuildContext , val view : NodeView = EmptyNodeView , plugins : List < Plugin > = emptyList () // <-- ) So what is a Plugin ? A Plugin is an empty interface extended by many actual ones: interface Plugin","title":"Keeping extra concerns out of Node"},{"location":"apps/plugins/#plugins_1","text":"","title":"Plugins"},{"location":"apps/plugins/#lifecycle-related-plugins","text":"interface NodeLifecycleAware : Plugin { fun onCreate ( lifecycle : Lifecycle ) {} } fun interface Destroyable : Plugin { fun destroy () }","title":"Lifecycle-related plugins"},{"location":"apps/plugins/#component-level-plugins","text":"Sometimes you need to grab a reference to the component as a whole, either as an interface, or its implementation, the Node . This will come especially handy when working with workflows. interface NodeAware : Plugin { val node : Node <*> fun init ( node : Node <*> ) {} } There are helper classes found in the library, so you don't have to implement the above interfaces, you can just use delegation: class SomeClass ( private val nodeAware : NodeAware = NodeAwareImpl () ) : NodeAware by nodeAware { fun foo () { // [node] is an automatically available property coming from the NodeAware interface // the reference is automatically set for you by the framework + the NodeAwareImpl class // so you can use it right away: node . doSomething () } } \u26a0\ufe0f Note: the reference to node is set by Node automatically, and isn't available immediately after constructing your object, but only after the construction of the Node itself.","title":"Component level plugins"},{"location":"apps/plugins/#navigation-plugins","text":"In case if you need to control navigation behaviour, you can use these plugins: interface UpNavigationHandler : Plugin { fun handleUpNavigation (): Boolean = false } interface BackPressHandler : Plugin { val onBackPressedCallback : OnBackPressedCallback? get () = null } UpNavigationHandler controls Node.navigateUp behaviour and allows to intercept its invocation. BackPressHandler controls device back press behaviour via androidx.activity.OnBackPressedCallback . You can read more about it here . \u26a0\ufe0f Note: OnBackPressedCallback are invoked in the following order: 1. From children to parents. Render order of children matters! The last rendered child will be the first to handle back press. 2. Direct order of plugins within a node. Plugins are invoked in order they appears in Node(plugins = ...) before the NavModel.","title":"Navigation plugins"},{"location":"apps/plugins/#using-plugins","text":"All plugins are designed to have empty {} default implementations (or other sensible defaults when a return value is defined), so it's convenient to implement them only if you need. Don't forget to pass your Plugins to your Node : internal class MyNode ( // ... plugins : List < Plugins > = emptyList () // ... ) : Node < Nothing > ( // ... plugins = plugins // ... ) \u26a0\ufe0f Note: plugins is a List , as the order matters here. All Plugin instances are invoked in the order they appear in the list.","title":"Using Plugins"},{"location":"apps/structure/","text":"Structuring your app navigation \u00b6 As seen in Composable navigation , you can make NavModels composable. To achieve this, Appyx offers the Node class as the structural element. Node illustration \u00b6 In many of the examples you'll see this panel as an illustration of a very simple Node \u2013 it has some local state (id, colour, and a counter). If you launch the sample app in the :app module, you can also change its state (colour) by tapping it. Its counter is stepped automatically. This is to illustrate that it has its own state, persisted and restored. Node overview \u00b6 You can think of a Node as a standalone component with: Its own simplified lifecycle State restoration A @Composable view Business logic that's kept alive even when the view isn't added to the composition The ability to host generic Plugins to extract extra concerns without enforcing any particular architectural pattern Parent nodes, child nodes \u00b6 ParentNodes can have other Nodes as children. This means you can represent your whole application as a tree of Appyx nodes. You can go as granular or as high-level as it fits you. This allows to keep the complexity low in individual Nodes by extracting responsibilities to children, as well as composing other components to build more complex functionality. Composable navigation \u00b6 Nodes offer the structure \u2013 NavModels add dynamism to it. Read more in Composable navigation Lifecycle \u00b6 Nodes have their own lifecycles, directly using the related classes of androidx.lifecycle . Read more in Lifecycle ChildAware API \u00b6 React to dynamically added child nodes in the tree: ChildAware API Summary \u00b6 A summary of Appyx's approach to structuring applications: Compose your app out of Nodes with their own lifecycles and state Navigation is local, composed of individual pieces of NavModels Navigation is stateful Navigation is unit-testable You're free to implement your own navigable components by utilising NavModels Avoid global navigation concerns, like shared modules needing to know about the application, or the application needing to know about all its possible modules","title":"Structuring your app navigation"},{"location":"apps/structure/#structuring-your-app-navigation","text":"As seen in Composable navigation , you can make NavModels composable. To achieve this, Appyx offers the Node class as the structural element.","title":"Structuring your app navigation"},{"location":"apps/structure/#node-illustration","text":"In many of the examples you'll see this panel as an illustration of a very simple Node \u2013 it has some local state (id, colour, and a counter). If you launch the sample app in the :app module, you can also change its state (colour) by tapping it. Its counter is stepped automatically. This is to illustrate that it has its own state, persisted and restored.","title":"Node illustration"},{"location":"apps/structure/#node-overview","text":"You can think of a Node as a standalone component with: Its own simplified lifecycle State restoration A @Composable view Business logic that's kept alive even when the view isn't added to the composition The ability to host generic Plugins to extract extra concerns without enforcing any particular architectural pattern","title":"Node overview"},{"location":"apps/structure/#parent-nodes-child-nodes","text":"ParentNodes can have other Nodes as children. This means you can represent your whole application as a tree of Appyx nodes. You can go as granular or as high-level as it fits you. This allows to keep the complexity low in individual Nodes by extracting responsibilities to children, as well as composing other components to build more complex functionality.","title":"Parent nodes, child nodes"},{"location":"apps/structure/#composable-navigation","text":"Nodes offer the structure \u2013 NavModels add dynamism to it. Read more in Composable navigation","title":"Composable navigation"},{"location":"apps/structure/#lifecycle","text":"Nodes have their own lifecycles, directly using the related classes of androidx.lifecycle . Read more in Lifecycle","title":"Lifecycle"},{"location":"apps/structure/#childaware-api","text":"React to dynamically added child nodes in the tree: ChildAware API","title":"ChildAware API"},{"location":"apps/structure/#summary","text":"A summary of Appyx's approach to structuring applications: Compose your app out of Nodes with their own lifecycles and state Navigation is local, composed of individual pieces of NavModels Navigation is stateful Navigation is unit-testable You're free to implement your own navigable components by utilising NavModels Avoid global navigation concerns, like shared modules needing to know about the application, or the application needing to know about all its possible modules","title":"Summary"},{"location":"how-to-use-appyx/codelabs/","text":"Appyx codelabs \u00b6 When you feel ready, try our Coding challenges too! 1. Hello World with Appyx \u00b6 Learn the basics of Appyx 2. Navigation \u00b6 Learn how Appyx navigation works 3. Custom animation \u00b6 Learn how to unleash powerful transitions","title":"Codelabs"},{"location":"how-to-use-appyx/codelabs/#appyx-codelabs","text":"When you feel ready, try our Coding challenges too!","title":"Appyx codelabs"},{"location":"how-to-use-appyx/codelabs/#1-hello-world-with-appyx","text":"Learn the basics of Appyx","title":"1. Hello World with Appyx"},{"location":"how-to-use-appyx/codelabs/#2-navigation","text":"Learn how Appyx navigation works","title":"2. Navigation"},{"location":"how-to-use-appyx/codelabs/#3-custom-animation","text":"Learn how to unleash powerful transitions","title":"3. Custom animation"},{"location":"how-to-use-appyx/coding-challenges/","text":"Appyx coding challenges \u00b6 Droidcon London 22 \u2013 Coding challenge 1 \u00b6 Test your knowledge of the key pieces of Appyx Droidcon London 22 \u2013 Coding challenge 2 \u00b6 A challenge with custom animations and a new operation","title":"Coding challenges"},{"location":"how-to-use-appyx/coding-challenges/#appyx-coding-challenges","text":"","title":"Appyx coding challenges"},{"location":"how-to-use-appyx/coding-challenges/#droidcon-london-22-coding-challenge-1","text":"Test your knowledge of the key pieces of Appyx","title":"Droidcon London 22 \u2013 Coding challenge 1"},{"location":"how-to-use-appyx/coding-challenges/#droidcon-london-22-coding-challenge-2","text":"A challenge with custom animations and a new operation","title":"Droidcon London 22 \u2013 Coding challenge 2"},{"location":"how-to-use-appyx/quick-start/","text":"Quick start guide \u00b6 Info You can check out App structure , which explains the concepts you'll encounter in this guide. You can check out the project and launch the :app module for a quick demonstration Tip Once you're familiar with Appyx, you can also clone the https://github.com/bumble-tech/appyx-starter-kit when starting a new project, instead of following this guide below. Scope of this guide \u00b6 The steps below will cover: Integrating Appyx into your project Creating a very simple Node hierarchy We'll use a simple back stack for navigation We'll add some simple transitions to it This should be enough to get you started as a rudimentary application structure. Tutorials & codelabs on more advanced topics & the full power of Appyx to follow soon. 1. Add Appyx to your project \u00b6 You can find the related Gradle dependencies in Downloads . 2. Create a root Node \u00b6 class RootNode ( buildContext : BuildContext ) : Node ( buildContext = buildContext ) { @Composable override fun View ( modifier : Modifier ) { Text ( \"Hello world!\" ) } } Since this is the root of your tree, you'll also need to plug it in to your Activity, so that system events (Android lifecycle, back press, etc.) reach your components in the tree. // Please note we are extending NodeActivity class MainActivity : NodeActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { AppTheme { NodeHost ( integrationPoint = appyxIntegrationPoint ) { RootNode ( buildContext = it ) } } } } } You only need to do this for the root of the tree. 3. Define children \u00b6 A single leaf node isn't all that interesting. Let's add some children to the root! First, let's define the possible set of children using a sealed class. We'll refer them via these navigation targets: /** * You can create this class inside the body of RootNode * * Note: You must apply the 'kotlin-parcelize' plugin to use @Parcelize * https://developer.android.com/kotlin/parcelize */ sealed class NavTarget : Parcelable { @Parcelize object Child1 : NavTarget () @Parcelize object Child2 : NavTarget () @Parcelize object Child3 : NavTarget () } Next, let's modify RootNode so it extends ParentNode : class RootNode ( buildContext : BuildContext ) : ParentNode < NavTarget > ( navModel = TODO ( \"We will come back to this in Step 4\" ), buildContext = buildContext ) { ParentNode expects us to implement the abstract method resolve . This is how we relate navigation targets to actual children. Let's use these helper methods to define some placeholders for the time being \u2013 we'll soon make them more appealing: override fun resolve ( navTarget : NavTarget , buildContext : BuildContext ): Node = when ( navTarget ) { NavTarget . Child1 -> node ( buildContext ) { Text ( text = \"Placeholder for child 1\" ) } NavTarget . Child2 -> node ( buildContext ) { Text ( text = \"Placeholder for child 2\" ) } NavTarget . Child3 -> node ( buildContext ) { Text ( text = \"Placeholder for child 3\" ) } } Great! With this mapping created, we can now just refer to children using the sealed class elements, and Appyx will be able to relate them to other nodes. 4. Add a back stack \u00b6 The project wouldn't compile just yet. ParentNode expects us to pass an instance of a NavModel \u2013 the main control structure in any case when we want to add children. No need to worry now \u2013 for simplicity, let's just go with a simple BackStack implementation here: class RootNode ( buildContext : BuildContext , private val backStack : BackStack < NavTarget > = BackStack ( initialElement = NavTarget . Child1 , savedStateMap = buildContext . savedStateMap , ) ) : ParentNode < NavTarget > ( navModel = backStack , // pass it here buildContext = buildContext ) { With this simple addition we've immediately gained a lot of power! Now we can use the back stack's API to add, replace, pop children with operations like: backStack . push ( NavTarget . Child2 ) // will add a new navigation target to the end of the stack and make it active backStack . replace ( NavTarget . Child3 ) // will replace the currently active child backStack . pop () // will remove the currently active child and restore the one before it Since we passed the back stack to the ParentNode , all such changes will be immediately reflected. We only need to add it to the composition: @Composable override fun View ( modifier : Modifier ) { Column { Text ( \"Hello world!\" ) // Let's add the children to the composition Children ( navModel = backStack ) // Let's also add some controls so we can test it Row { TextButton ( onClick = { backStack . push ( NavTarget . Child1 ) }) { Text ( text = \"Push child 1\" ) } TextButton ( onClick = { backStack . push ( NavTarget . Child2 ) }) { Text ( text = \"Push child 2\" ) } TextButton ( onClick = { backStack . push ( NavTarget . Child3 ) }) { Text ( text = \"Push child 3\" ) } TextButton ( onClick = { backStack . pop () }) { Text ( text = \"Pop\" ) } } } } 5. Add transitions \u00b6 Adding some transitions is a one-liner: Children ( navModel = backStack , transitionHandler = rememberBackstackSlider () ) You can also use a fader instead: rememberBackstackFader() , and you can supply a transition spec in both cases: rememberBackStackSlider { spring(stiffness = Spring.StiffnessLow) } Need something more custom? Instead of a back stack, you can find other NavModels in the library, or you can implement your own Instead of the default transition handlers, you can also use Jetpack Compose provided ones, or supply your own You can also read the Back stack documentation for more info on the specific options for the back stack. 6. Proper child nodes \u00b6 As a last step, let's replace at least one of the child placeholders with another proper node. Let's create a dedicated class: class SomeChildNode ( buildContext : BuildContext ) : Node ( buildContext = buildContext ) { @Composable override fun View ( modifier : Modifier ) { Text ( \"This is SomeChildNode\" ) } } Now we can update the resolve method in RootNode so that the target Child3 refers to this node. It should work out of the box: override fun resolve ( navTarget : NavTarget , buildContext : BuildContext ): Node = when ( navTarget ) { NavTarget . Child1 -> node ( buildContext ) { Text ( text = \"Placeholder for child 1\" ) } NavTarget . Child2 -> node ( buildContext ) { Text ( text = \"Placeholder for child 2\" ) } NavTarget . Child3 -> SomeChildNode ( buildContext ) } What's next? \u00b6 Congrats, you've just built your first Appyx tree! You can repeat the same pattern and make any embedded children also a ParentNode with their own children, navigation models, and transitions. As complexity grows, generally you would: Have a Node At some point make it a ParentNode and add children to it At some point extract the increasing complexity from a placeholder to another Node Repeat the same on children, go to 1. Further reading \u00b6 Check out Model-driven navigation how to take your navigation to the next level You can (and probably should) also extract local business logic, the view, any any other components into separate classes and Plugins .","title":"Quick start guide"},{"location":"how-to-use-appyx/quick-start/#quick-start-guide","text":"Info You can check out App structure , which explains the concepts you'll encounter in this guide. You can check out the project and launch the :app module for a quick demonstration Tip Once you're familiar with Appyx, you can also clone the https://github.com/bumble-tech/appyx-starter-kit when starting a new project, instead of following this guide below.","title":"Quick start guide"},{"location":"how-to-use-appyx/quick-start/#scope-of-this-guide","text":"The steps below will cover: Integrating Appyx into your project Creating a very simple Node hierarchy We'll use a simple back stack for navigation We'll add some simple transitions to it This should be enough to get you started as a rudimentary application structure. Tutorials & codelabs on more advanced topics & the full power of Appyx to follow soon.","title":"Scope of this guide"},{"location":"how-to-use-appyx/quick-start/#1-add-appyx-to-your-project","text":"You can find the related Gradle dependencies in Downloads .","title":"1. Add Appyx to your project"},{"location":"how-to-use-appyx/quick-start/#2-create-a-root-node","text":"class RootNode ( buildContext : BuildContext ) : Node ( buildContext = buildContext ) { @Composable override fun View ( modifier : Modifier ) { Text ( \"Hello world!\" ) } } Since this is the root of your tree, you'll also need to plug it in to your Activity, so that system events (Android lifecycle, back press, etc.) reach your components in the tree. // Please note we are extending NodeActivity class MainActivity : NodeActivity () { override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { AppTheme { NodeHost ( integrationPoint = appyxIntegrationPoint ) { RootNode ( buildContext = it ) } } } } } You only need to do this for the root of the tree.","title":"2. Create a root Node"},{"location":"how-to-use-appyx/quick-start/#3-define-children","text":"A single leaf node isn't all that interesting. Let's add some children to the root! First, let's define the possible set of children using a sealed class. We'll refer them via these navigation targets: /** * You can create this class inside the body of RootNode * * Note: You must apply the 'kotlin-parcelize' plugin to use @Parcelize * https://developer.android.com/kotlin/parcelize */ sealed class NavTarget : Parcelable { @Parcelize object Child1 : NavTarget () @Parcelize object Child2 : NavTarget () @Parcelize object Child3 : NavTarget () } Next, let's modify RootNode so it extends ParentNode : class RootNode ( buildContext : BuildContext ) : ParentNode < NavTarget > ( navModel = TODO ( \"We will come back to this in Step 4\" ), buildContext = buildContext ) { ParentNode expects us to implement the abstract method resolve . This is how we relate navigation targets to actual children. Let's use these helper methods to define some placeholders for the time being \u2013 we'll soon make them more appealing: override fun resolve ( navTarget : NavTarget , buildContext : BuildContext ): Node = when ( navTarget ) { NavTarget . Child1 -> node ( buildContext ) { Text ( text = \"Placeholder for child 1\" ) } NavTarget . Child2 -> node ( buildContext ) { Text ( text = \"Placeholder for child 2\" ) } NavTarget . Child3 -> node ( buildContext ) { Text ( text = \"Placeholder for child 3\" ) } } Great! With this mapping created, we can now just refer to children using the sealed class elements, and Appyx will be able to relate them to other nodes.","title":"3. Define children"},{"location":"how-to-use-appyx/quick-start/#4-add-a-back-stack","text":"The project wouldn't compile just yet. ParentNode expects us to pass an instance of a NavModel \u2013 the main control structure in any case when we want to add children. No need to worry now \u2013 for simplicity, let's just go with a simple BackStack implementation here: class RootNode ( buildContext : BuildContext , private val backStack : BackStack < NavTarget > = BackStack ( initialElement = NavTarget . Child1 , savedStateMap = buildContext . savedStateMap , ) ) : ParentNode < NavTarget > ( navModel = backStack , // pass it here buildContext = buildContext ) { With this simple addition we've immediately gained a lot of power! Now we can use the back stack's API to add, replace, pop children with operations like: backStack . push ( NavTarget . Child2 ) // will add a new navigation target to the end of the stack and make it active backStack . replace ( NavTarget . Child3 ) // will replace the currently active child backStack . pop () // will remove the currently active child and restore the one before it Since we passed the back stack to the ParentNode , all such changes will be immediately reflected. We only need to add it to the composition: @Composable override fun View ( modifier : Modifier ) { Column { Text ( \"Hello world!\" ) // Let's add the children to the composition Children ( navModel = backStack ) // Let's also add some controls so we can test it Row { TextButton ( onClick = { backStack . push ( NavTarget . Child1 ) }) { Text ( text = \"Push child 1\" ) } TextButton ( onClick = { backStack . push ( NavTarget . Child2 ) }) { Text ( text = \"Push child 2\" ) } TextButton ( onClick = { backStack . push ( NavTarget . Child3 ) }) { Text ( text = \"Push child 3\" ) } TextButton ( onClick = { backStack . pop () }) { Text ( text = \"Pop\" ) } } } }","title":"4. Add a back stack"},{"location":"how-to-use-appyx/quick-start/#5-add-transitions","text":"Adding some transitions is a one-liner: Children ( navModel = backStack , transitionHandler = rememberBackstackSlider () ) You can also use a fader instead: rememberBackstackFader() , and you can supply a transition spec in both cases: rememberBackStackSlider { spring(stiffness = Spring.StiffnessLow) } Need something more custom? Instead of a back stack, you can find other NavModels in the library, or you can implement your own Instead of the default transition handlers, you can also use Jetpack Compose provided ones, or supply your own You can also read the Back stack documentation for more info on the specific options for the back stack.","title":"5. Add transitions"},{"location":"how-to-use-appyx/quick-start/#6-proper-child-nodes","text":"As a last step, let's replace at least one of the child placeholders with another proper node. Let's create a dedicated class: class SomeChildNode ( buildContext : BuildContext ) : Node ( buildContext = buildContext ) { @Composable override fun View ( modifier : Modifier ) { Text ( \"This is SomeChildNode\" ) } } Now we can update the resolve method in RootNode so that the target Child3 refers to this node. It should work out of the box: override fun resolve ( navTarget : NavTarget , buildContext : BuildContext ): Node = when ( navTarget ) { NavTarget . Child1 -> node ( buildContext ) { Text ( text = \"Placeholder for child 1\" ) } NavTarget . Child2 -> node ( buildContext ) { Text ( text = \"Placeholder for child 2\" ) } NavTarget . Child3 -> SomeChildNode ( buildContext ) }","title":"6. Proper child nodes"},{"location":"how-to-use-appyx/quick-start/#whats-next","text":"Congrats, you've just built your first Appyx tree! You can repeat the same pattern and make any embedded children also a ParentNode with their own children, navigation models, and transitions. As complexity grows, generally you would: Have a Node At some point make it a ParentNode and add children to it At some point extract the increasing complexity from a placeholder to another Node Repeat the same on children, go to 1.","title":"What's next?"},{"location":"how-to-use-appyx/quick-start/#further-reading","text":"Check out Model-driven navigation how to take your navigation to the next level You can (and probably should) also extract local business logic, the view, any any other components into separate classes and Plugins .","title":"Further reading"},{"location":"how-to-use-appyx/sample-apps/","text":"Appyx sample apps \u00b6 Where to find the sample apps \u00b6 Go to the GitHub project Fork and check out the code locally Import the project to Android Studio You can find the pre-built sample app apks here: Latest release Latest 1.x Showcase app \u00b6 The :app module showcases Appyx itself with multiple levels of navigation, NavModel demos, etc. See it in action, then check the related code how it works. Appyx + Jetpack Compose Navigation example \u00b6 The :samples:navigation-compose module demonstrates how to use Appyx within Google's Jetpack Compose Navigation library. This example may be useful if you need to migrate to Appyx gradually. Appyx + Hilt example \u00b6 Coming soon! Meanwhile: Our draft PR: #115 (Feel free to provide feedback!) https://github.com/jbreitfeller-sfix/appyx-playground another approach on this topic","title":"Sample apps"},{"location":"how-to-use-appyx/sample-apps/#appyx-sample-apps","text":"","title":"Appyx sample apps"},{"location":"how-to-use-appyx/sample-apps/#where-to-find-the-sample-apps","text":"Go to the GitHub project Fork and check out the code locally Import the project to Android Studio You can find the pre-built sample app apks here: Latest release Latest 1.x","title":"Where to find the sample apps"},{"location":"how-to-use-appyx/sample-apps/#showcase-app","text":"The :app module showcases Appyx itself with multiple levels of navigation, NavModel demos, etc. See it in action, then check the related code how it works.","title":"Showcase app"},{"location":"how-to-use-appyx/sample-apps/#appyx-jetpack-compose-navigation-example","text":"The :samples:navigation-compose module demonstrates how to use Appyx within Google's Jetpack Compose Navigation library. This example may be useful if you need to migrate to Appyx gradually.","title":"Appyx + Jetpack Compose Navigation example"},{"location":"how-to-use-appyx/sample-apps/#appyx-hilt-example","text":"Coming soon! Meanwhile: Our draft PR: #115 (Feel free to provide feedback!) https://github.com/jbreitfeller-sfix/appyx-playground another approach on this topic","title":"Appyx + Hilt example"},{"location":"navigation/composable-navigation/","text":"Composable navigation \u00b6 NavModels in Appyx are composable. As a single NavModel won't be enough for the whole of your whole app, you can use many in a composable way. That is, any navigation target of a NavModel can also host its own NavModel . Structural element for composing navigation \u00b6 Nodes are the main structural element in Appyx. They can host NavModels , and they form a tree. This allows you to make your app's business logic also composable by leveraging Nodes as lifecycled components. Read more in Structuring your app navigation Navigation in the tree \u00b6 Once you've structured your navigation in a composable way, you can add NavModels to Node of this tree and make it dynamic: Some parts in this tree are active while others ore not The active parts define what state the application is in, and what the user sees on the screen We can change what's active by using NavModels on each level of the tree Changes will feel like navigation to the user See Implicit navigation and Explicit navigation for building complex navigation behaviours with this approach. How NavModels affect Nodes \u00b6 NavModel operations will typically result in: Adding or removing child Nodes of a ParentNode Move them on and off the screen Change their states As an illustration: Here: Back stack illustrates adding and removing child Nodes Tiles illustrates changing the state of children and removing them from the ParentNode These are just two examples, you're of course not limited to using them.","title":"Composable navigation"},{"location":"navigation/composable-navigation/#composable-navigation","text":"NavModels in Appyx are composable. As a single NavModel won't be enough for the whole of your whole app, you can use many in a composable way. That is, any navigation target of a NavModel can also host its own NavModel .","title":"Composable navigation"},{"location":"navigation/composable-navigation/#structural-element-for-composing-navigation","text":"Nodes are the main structural element in Appyx. They can host NavModels , and they form a tree. This allows you to make your app's business logic also composable by leveraging Nodes as lifecycled components. Read more in Structuring your app navigation","title":"Structural element for composing navigation"},{"location":"navigation/composable-navigation/#navigation-in-the-tree","text":"Once you've structured your navigation in a composable way, you can add NavModels to Node of this tree and make it dynamic: Some parts in this tree are active while others ore not The active parts define what state the application is in, and what the user sees on the screen We can change what's active by using NavModels on each level of the tree Changes will feel like navigation to the user See Implicit navigation and Explicit navigation for building complex navigation behaviours with this approach.","title":"Navigation in the tree"},{"location":"navigation/composable-navigation/#how-navmodels-affect-nodes","text":"NavModel operations will typically result in: Adding or removing child Nodes of a ParentNode Move them on and off the screen Change their states As an illustration: Here: Back stack illustrates adding and removing child Nodes Tiles illustrates changing the state of children and removing them from the ParentNode These are just two examples, you're of course not limited to using them.","title":"How NavModels affect Nodes"},{"location":"navigation/deep-linking/","text":"Deep linking \u00b6 Building on top of explicit navigation , implementing deep links is straightforward: class ExplicitNavigationExampleActivity : NodeActivity (), Navigator { lateinit var rootNode : RootNode fun handleDeepLink ( intent : Intent ) { if ( intent . action == Intent . ACTION_VIEW ) { when { ( it . data ?. host == \"onboarding\" ) -> navigateToOnBoarding () else -> Unit } } } override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { NodeHost ( integrationPoint = appyxIntegrationPoint ) { RootNode ( buildContext = it , plugins = listOf ( object : NodeReadyObserver < RootNode > { override fun init ( node : RootNode ) { rootNode = node handleDeepLink ( intent = intent ) } }) ) } } } private fun navigateToOnBoarding () { // implement explicit navigation } } Check ExplicitNavigationExampleActivity in the samples to inspect the full code.","title":"Deep linking"},{"location":"navigation/deep-linking/#deep-linking","text":"Building on top of explicit navigation , implementing deep links is straightforward: class ExplicitNavigationExampleActivity : NodeActivity (), Navigator { lateinit var rootNode : RootNode fun handleDeepLink ( intent : Intent ) { if ( intent . action == Intent . ACTION_VIEW ) { when { ( it . data ?. host == \"onboarding\" ) -> navigateToOnBoarding () else -> Unit } } } override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { NodeHost ( integrationPoint = appyxIntegrationPoint ) { RootNode ( buildContext = it , plugins = listOf ( object : NodeReadyObserver < RootNode > { override fun init ( node : RootNode ) { rootNode = node handleDeepLink ( intent = intent ) } }) ) } } } private fun navigateToOnBoarding () { // implement explicit navigation } } Check ExplicitNavigationExampleActivity in the samples to inspect the full code.","title":"Deep linking"},{"location":"navigation/explicit-navigation/","text":"Explicit navigation \u00b6 When Implicit navigation doesn't fit your use case, you can try an explicit approach. Relevant methods ParentNode.attachChild() ParentNode.waitForChildAttached() Using these methods we can chain together a path which leads from the root of the tree to a specific Node . Use case \u00b6 We want to navigate from Chat to onboarding's first screen O1 : This time we'll want to do this explicitly by calling a function. The plan \u00b6 Create a public method on Root that attaches Onboarding Create a public method on Onboarding that attaches the first onboarding screen Create a Navigator , that starting from an instance of Root , can chain these public methods together into a single action: navigateToO1() Capture an instance of Root to use with Navigator Call navigateToO1() on our Navigator instance Step 1 \u2013 Root \u2192 Onboarding \u00b6 First, we need to define how to programmatically attach Onboarding to the Root : class RootNode ( buildContext : BuildContext , backStack : BackStack < NavTarget > ) : ParentNode < NavTarget > ( buildContext = buildContext , navModel = backStack , ) { suspend fun attachOnboarding (): OnboardingNode { return attachChild { backStack . replace ( NavTarget . Onboarding ) } } } Let's break down what happens here: Since attachChild has a generic <T> return type, it will conform to the defined OnboardingNode type However, attachChild doesn't know how to create navigation to OnboardingNode \u2013 that's something only we can do with the provided lambda We replace NavTarget.Onboarding into the back stack Doing this should result in OnboardingNode being created and added to RootNode as a child attachChild expects an instance of OnboardingNode to appear as a child of Root as a consequence of executing our lambda Once it appears, attachChild returns it Important It's our responsibility to make sure that the provided lambda actually results in the expected child being added. If we accidentally do something else instead, for example: suspend fun attachOnboarding (): OnboardingNode { return attachChild { backStack . replace ( NavTarget . Main ) // Wrong NavTarget } } Then an exception will be thrown after a timeout. Step 2 \u2013 Onboarding \u2192 O1 \u00b6 Unlike Root , Onboarding uses Spotlight instead of BackStack as a NavModel , so navigation to the first screen is slightly different: class OnboardingNode ( buildContext : BuildContext , spotlight : Spotlight < NavTarget > ) : ParentNode < NavTarget > ( buildContext = buildContext , navModel = spotlight , ) { suspend fun attachO1 (): O1Node { return attachChild { spotlight . activate ( index = 0 ) } } } Step 3 \u2013 Our Navigator \u00b6 interface Navigator { fun navigateToO1 () } In this case we'll implement it directly with our activity: class ExplicitNavigationExampleActivity : NodeActivity (), Navigator { lateinit var rootNode : RootNode // See the next step override fun navigateToO1 () { lifecycleScope . launch { rootNode . attachOnboarding () . attachO1 () } } } Step 4 \u2013 An instance of RootNode \u00b6 As the last piece of the puzzle, we'll also need to capture the instance of RootNode to make it all work. We can do that by a NodeReadyObserver plugin when setting up our tree: class ExplicitNavigationExampleActivity : NodeActivity (), Navigator { lateinit var rootNode : RootNode override fun navigateToO1 () { /*...*/ } override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { NodeHost ( integrationPoint = appyxIntegrationPoint ) { RootNode ( buildContext = it , navigator = this @ExplicitNavigationExampleActivity , plugins = listOf ( object : NodeReadyObserver < RootNode > { override fun init ( node : RootNode ) { rootNode = node } }) ) } } } } Step 5 \u2013 Using the Navigator \u00b6 See how in the previous snippet RootNode receives a navigator dependency. It can pass it further down the tree as a dependency to other nodes. Those nodes can call the methods of the Navigator , which will change the global navigation state directly. Bonus: Wait for a child to be attached \u00b6 There might be cases when we want to wait for a certain action to be performed by the user , rather than us, to result in a child being attached. In these cases we can use ParentNode.waitForChildAttached() instead. Use case \u2013 Wait for login \u00b6 A typical case building an explicit navigation chain that relies on Logged in being attached. Most probably Logged in has a dependency on some kind of a User object. Here we want to wait for the user to authenticate themselves, rather than creating a dummy user object ourselves. class RootNode ( buildContext : BuildContext , ) : ParentNode < NavTarget > ( buildContext = buildContext ) { suspend fun waitForLoggedIn (): LoggedInNode = waitForChildAttached < LoggedInNode > () } This method will wait for LoggedInNode to appear in the child list of RootNode and return with it. If it's already there, it returns immediately. A navigation chain using it could look like: class ExplicitNavigationExampleActivity : NodeActivity (), Navigator { override fun navigateToProfile () { lifecycleScope . launch { rootNode . waitForLoggedIn () . attachMain () . attachProfile () } } } You can find related code examples in ExplicitNavigationExampleActivity in our samples.","title":"Explicit navigation"},{"location":"navigation/explicit-navigation/#explicit-navigation","text":"When Implicit navigation doesn't fit your use case, you can try an explicit approach. Relevant methods ParentNode.attachChild() ParentNode.waitForChildAttached() Using these methods we can chain together a path which leads from the root of the tree to a specific Node .","title":"Explicit navigation"},{"location":"navigation/explicit-navigation/#use-case","text":"We want to navigate from Chat to onboarding's first screen O1 : This time we'll want to do this explicitly by calling a function.","title":"Use case"},{"location":"navigation/explicit-navigation/#the-plan","text":"Create a public method on Root that attaches Onboarding Create a public method on Onboarding that attaches the first onboarding screen Create a Navigator , that starting from an instance of Root , can chain these public methods together into a single action: navigateToO1() Capture an instance of Root to use with Navigator Call navigateToO1() on our Navigator instance","title":"The plan"},{"location":"navigation/explicit-navigation/#step-1-root-onboarding","text":"First, we need to define how to programmatically attach Onboarding to the Root : class RootNode ( buildContext : BuildContext , backStack : BackStack < NavTarget > ) : ParentNode < NavTarget > ( buildContext = buildContext , navModel = backStack , ) { suspend fun attachOnboarding (): OnboardingNode { return attachChild { backStack . replace ( NavTarget . Onboarding ) } } } Let's break down what happens here: Since attachChild has a generic <T> return type, it will conform to the defined OnboardingNode type However, attachChild doesn't know how to create navigation to OnboardingNode \u2013 that's something only we can do with the provided lambda We replace NavTarget.Onboarding into the back stack Doing this should result in OnboardingNode being created and added to RootNode as a child attachChild expects an instance of OnboardingNode to appear as a child of Root as a consequence of executing our lambda Once it appears, attachChild returns it Important It's our responsibility to make sure that the provided lambda actually results in the expected child being added. If we accidentally do something else instead, for example: suspend fun attachOnboarding (): OnboardingNode { return attachChild { backStack . replace ( NavTarget . Main ) // Wrong NavTarget } } Then an exception will be thrown after a timeout.","title":"Step 1 \u2013 Root \u2192 Onboarding"},{"location":"navigation/explicit-navigation/#step-2-onboarding-o1","text":"Unlike Root , Onboarding uses Spotlight instead of BackStack as a NavModel , so navigation to the first screen is slightly different: class OnboardingNode ( buildContext : BuildContext , spotlight : Spotlight < NavTarget > ) : ParentNode < NavTarget > ( buildContext = buildContext , navModel = spotlight , ) { suspend fun attachO1 (): O1Node { return attachChild { spotlight . activate ( index = 0 ) } } }","title":"Step 2 \u2013 Onboarding \u2192 O1"},{"location":"navigation/explicit-navigation/#step-3-our-navigator","text":"interface Navigator { fun navigateToO1 () } In this case we'll implement it directly with our activity: class ExplicitNavigationExampleActivity : NodeActivity (), Navigator { lateinit var rootNode : RootNode // See the next step override fun navigateToO1 () { lifecycleScope . launch { rootNode . attachOnboarding () . attachO1 () } } }","title":"Step 3 \u2013 Our Navigator"},{"location":"navigation/explicit-navigation/#step-4-an-instance-of-rootnode","text":"As the last piece of the puzzle, we'll also need to capture the instance of RootNode to make it all work. We can do that by a NodeReadyObserver plugin when setting up our tree: class ExplicitNavigationExampleActivity : NodeActivity (), Navigator { lateinit var rootNode : RootNode override fun navigateToO1 () { /*...*/ } override fun onCreate ( savedInstanceState : Bundle?) { super . onCreate ( savedInstanceState ) setContent { NodeHost ( integrationPoint = appyxIntegrationPoint ) { RootNode ( buildContext = it , navigator = this @ExplicitNavigationExampleActivity , plugins = listOf ( object : NodeReadyObserver < RootNode > { override fun init ( node : RootNode ) { rootNode = node } }) ) } } } }","title":"Step 4 \u2013 An instance of RootNode"},{"location":"navigation/explicit-navigation/#step-5-using-the-navigator","text":"See how in the previous snippet RootNode receives a navigator dependency. It can pass it further down the tree as a dependency to other nodes. Those nodes can call the methods of the Navigator , which will change the global navigation state directly.","title":"Step 5 \u2013 Using the Navigator"},{"location":"navigation/explicit-navigation/#bonus-wait-for-a-child-to-be-attached","text":"There might be cases when we want to wait for a certain action to be performed by the user , rather than us, to result in a child being attached. In these cases we can use ParentNode.waitForChildAttached() instead.","title":"Bonus: Wait for a child to be attached"},{"location":"navigation/explicit-navigation/#use-case-wait-for-login","text":"A typical case building an explicit navigation chain that relies on Logged in being attached. Most probably Logged in has a dependency on some kind of a User object. Here we want to wait for the user to authenticate themselves, rather than creating a dummy user object ourselves. class RootNode ( buildContext : BuildContext , ) : ParentNode < NavTarget > ( buildContext = buildContext ) { suspend fun waitForLoggedIn (): LoggedInNode = waitForChildAttached < LoggedInNode > () } This method will wait for LoggedInNode to appear in the child list of RootNode and return with it. If it's already there, it returns immediately. A navigation chain using it could look like: class ExplicitNavigationExampleActivity : NodeActivity (), Navigator { override fun navigateToProfile () { lifecycleScope . launch { rootNode . waitForLoggedIn () . attachMain () . attachProfile () } } } You can find related code examples in ExplicitNavigationExampleActivity in our samples.","title":"Use case \u2013 Wait for login"},{"location":"navigation/implicit-navigation/","text":"Implicit navigation \u00b6 How can we go from one part of the tree to another? In almost all cases navigation can be implicit instead of explicit. We don't need to specify the target \u2013 navigation will happen as a consequence of individual pieces of the puzzle. Relevant methods ParentNode.onChildFinished(child: Node) can be overridden by client code to handle a child finishing Node.finish() invokes the above method on its parent Use-case 1 \u00b6 Requirement \u00b6 After onboarding finishes, the user should land in the message list screen. Solution \u00b6 O3 calls its finish() method Onboarding notices O3 finished; if it had more children, it could switch to another; now it calls finish() too Logged in notices Onboarding finished, and switches its navigation to Main Main is initialised, and loads its default navigation target (based on product requirements) to be Messages Messages is initialised, and loads its default navigation target to be List Bonus Every Node in the above sequence only needed to care about its own local concern. Use-case 2 \u00b6 Requirement \u00b6 Pressing the logout button on the profile screen should land us back to the login screen. Solution \u00b6 Root either implements a logout callback, or subscribes to the changes of a user repository; in both cases, either the callback or the repository is passed down the tree as a dependency Profile invokes the callback or a logout method on the repository Root notices the state change, and switches its navigation to the Logged out scope Logged out loads its initial navigation target, Login Bonus Note how the entire Logged in scope is destroyed without any extra effort. The next time a login happens, all state is created anew. Summary \u00b6 Implicit navigation allows you to implement navigation without introducing unnecessary coupling in the tree, and successfully covers the majority of navigation scenarios. In case it's not enough to meet your needs, see the next chapter, Explicit navigation","title":"Implicit navigation"},{"location":"navigation/implicit-navigation/#implicit-navigation","text":"How can we go from one part of the tree to another? In almost all cases navigation can be implicit instead of explicit. We don't need to specify the target \u2013 navigation will happen as a consequence of individual pieces of the puzzle. Relevant methods ParentNode.onChildFinished(child: Node) can be overridden by client code to handle a child finishing Node.finish() invokes the above method on its parent","title":"Implicit navigation"},{"location":"navigation/implicit-navigation/#use-case-1","text":"","title":"Use-case 1"},{"location":"navigation/implicit-navigation/#requirement","text":"After onboarding finishes, the user should land in the message list screen.","title":"Requirement"},{"location":"navigation/implicit-navigation/#solution","text":"O3 calls its finish() method Onboarding notices O3 finished; if it had more children, it could switch to another; now it calls finish() too Logged in notices Onboarding finished, and switches its navigation to Main Main is initialised, and loads its default navigation target (based on product requirements) to be Messages Messages is initialised, and loads its default navigation target to be List Bonus Every Node in the above sequence only needed to care about its own local concern.","title":"Solution"},{"location":"navigation/implicit-navigation/#use-case-2","text":"","title":"Use-case 2"},{"location":"navigation/implicit-navigation/#requirement_1","text":"Pressing the logout button on the profile screen should land us back to the login screen.","title":"Requirement"},{"location":"navigation/implicit-navigation/#solution_1","text":"Root either implements a logout callback, or subscribes to the changes of a user repository; in both cases, either the callback or the repository is passed down the tree as a dependency Profile invokes the callback or a logout method on the repository Root notices the state change, and switches its navigation to the Logged out scope Logged out loads its initial navigation target, Login Bonus Note how the entire Logged in scope is destroyed without any extra effort. The next time a login happens, all state is created anew.","title":"Solution"},{"location":"navigation/implicit-navigation/#summary","text":"Implicit navigation allows you to implement navigation without introducing unnecessary coupling in the tree, and successfully covers the majority of navigation scenarios. In case it's not enough to meet your needs, see the next chapter, Explicit navigation","title":"Summary"},{"location":"navigation/model-driven-navigation/","text":"Model-driven navigation \u00b6 Your own navigation model \u00b6 Generally speaking, most navigation solutions have fixed navigation mechanisms (e.g. a back stack). Appyx gives you the freedom to define your own navigation model. For example, you can implement any of the examples you see here with the same approach: No screen, only a viewport \u00b6 Generally speaking, most navigation solutions model a \"Screen\" and focus on how to get from one screen to another. Appyx does not have the concept of the screen in its model \u2013 there's only a viewport, and whatever fills the available space will feel like the screen to the user. This freedom allows you to implement: navigation that feels like going from \"screen to screen\" navigation \"inside the screen\" navigation that bridges between the two For example, you can transform the screen itself as part of navigation: NavModels \u00b6 A NavModel implements any of the above mechanisms. See NavModels for more details. Composable navigation \u00b6 NavModels in Appyx are composable. See Composable navigation for more details.","title":"Model-driven navigation"},{"location":"navigation/model-driven-navigation/#model-driven-navigation","text":"","title":"Model-driven navigation"},{"location":"navigation/model-driven-navigation/#your-own-navigation-model","text":"Generally speaking, most navigation solutions have fixed navigation mechanisms (e.g. a back stack). Appyx gives you the freedom to define your own navigation model. For example, you can implement any of the examples you see here with the same approach:","title":"Your own navigation model"},{"location":"navigation/model-driven-navigation/#no-screen-only-a-viewport","text":"Generally speaking, most navigation solutions model a \"Screen\" and focus on how to get from one screen to another. Appyx does not have the concept of the screen in its model \u2013 there's only a viewport, and whatever fills the available space will feel like the screen to the user. This freedom allows you to implement: navigation that feels like going from \"screen to screen\" navigation \"inside the screen\" navigation that bridges between the two For example, you can transform the screen itself as part of navigation:","title":"No screen, only a viewport"},{"location":"navigation/model-driven-navigation/#navmodels","text":"A NavModel implements any of the above mechanisms. See NavModels for more details.","title":"NavModels"},{"location":"navigation/model-driven-navigation/#composable-navigation","text":"NavModels in Appyx are composable. See Composable navigation for more details.","title":"Composable navigation"},{"location":"navmodel/","text":"Navigation models \u00b6 Navigation model is a core concept of Appyx. What's a NavModel? \u00b6 Navigation models describe navigation itself \u2013 by the states and operations they define, any custom navigation mechanism can be implemented. NavModel capabilities differ across implementations, however, typically: They store information on the states of all children They behave like a state machine They offer some public API to trigger changing the state of children Some examples of navigation models \u00b6 You can take a look at some of these examples: Back stack Spotlight Tiles Promoter carousel When you feel ready, you can try to implement your own NavModel . What does a NavModel not do? \u00b6 The NavModel represents only the model, not the looks: UI representation depends on your @Composable view hosting the children \u2013 See Adding children to the view Transition animations (if any) is a separate concern","title":"Overview"},{"location":"navmodel/#navigation-models","text":"Navigation model is a core concept of Appyx.","title":"Navigation models"},{"location":"navmodel/#whats-a-navmodel","text":"Navigation models describe navigation itself \u2013 by the states and operations they define, any custom navigation mechanism can be implemented. NavModel capabilities differ across implementations, however, typically: They store information on the states of all children They behave like a state machine They offer some public API to trigger changing the state of children","title":"What's a NavModel?"},{"location":"navmodel/#some-examples-of-navigation-models","text":"You can take a look at some of these examples: Back stack Spotlight Tiles Promoter carousel When you feel ready, you can try to implement your own NavModel .","title":"Some examples of navigation models"},{"location":"navmodel/#what-does-a-navmodel-not-do","text":"The NavModel represents only the model, not the looks: UI representation depends on your @Composable view hosting the children \u2013 See Adding children to the view Transition animations (if any) is a separate concern","title":"What does a NavModel not do?"},{"location":"navmodel/backstack/","text":"Back stack \u00b6 Implements a simple linear history: The last element at the end of the stack is considered \"active\". All other elements are considered stashed. Children associated with stashed elements are off the screen but kept alive (see how the counter values reflect this on the video) The back stack can never be empty \u2013 it always contains at least one element. The back stack also supports different back press and operation strategies (see further down below). States \u00b6 enum class State { CREATED , ACTIVE , STASHED , DESTROYED , } Visualisation of states \u00b6 Check out the apps in our Coding challenges \u2013 they have an embedded visualisation of what happens to all the elements inside the back stack (look at the row of orange boxes below the logo). Constructing the back stack \u00b6 As the back stack can never be empty, it's required to define an initial target. class BackStack < NavTarget : Any > ( initialElement : NavTarget , savedStateMap : SavedStateMap?, // Optional parameters are omitted ) Default on screen resolution \u00b6 As a default, only the active element is considered on screen. object BackStackOnScreenResolver : OnScreenStateResolver < State > { override fun isOnScreen ( state : State ): Boolean = when ( state ) { State . CREATED , State . STASHED , State . DESTROYED -> false State . ACTIVE -> true } } Default transition handlers \u00b6 BackStackFader \u00b6 rememberBackstackFader() Adds simple cross-fading transitions BackStackSlider \u00b6 rememberBackstackSlider() Adds horizontal sliding transitions so that the ACTIVE element is in the center; other states are animated from / to the left or the right edge of the screen. Operations \u00b6 Push \u00b6 backStack.push(navTarget) Effect on stack: [A, B, C] + Push(D) = [A, B, C, D] Transitions the active element ACTIVE -> STASHED . Adds a new element at the end of the stack with a CREATED -> ACTIVE transition. Replace \u00b6 backStack.replace(navTarget) Effect on stack: [A, B, C] + Replace(D) = [A, B, D] Transitions the active element ACTIVE -> DESTROYED , which will be removed when the transition finishes. Adds a new element at the end of the stack with a CREATED -> ACTIVE transition. Pop \u00b6 backStack.pop(navTarget) Effect on stack: [A, B, C] + Pop = [A, B] Transitions the active element ACTIVE -> DESTROYED , which will be removed when the transition finishes. Transitions the last stashed element STASHED -> ACTIVE . Single top \u00b6 backStack.singleTop(navTarget) Effect on stack: depends on the contents of the stack: [A, B, C, D] + SingleTop(B) = [A, B] // of same type and equals, acts as n * Pop [A, B, C, D] + SingleTop(B') = [A, B'] // of same type but not equals, acts as n * Pop + Replace [A, B, C, D] + SingleTop(E) = [A, B, C, D, E] // not found, acts as Push Back press strategy \u00b6 You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class BackStack < NavTarget : Any > ( /* ... */ backPressHandler : BackPressHandlerStrategy < NavTarget , State > = PopBackPressHandler (), /* ... */ ) PopBackPressHandler \u00b6 The default back press handling strategy. Runs a Pop operation. DontHandleBackPress \u00b6 Serves as a no-op. Operation strategy \u00b6 You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class BackStack < NavTarget : Any > ( /* ... */ operationStrategy : OperationStrategy < NavTarget , State > = ExecuteImmediately (), /* ... */ ) ExecuteImmediately \u00b6 The default strategy. New operations are executed without any questions, regardless of any already running transitions. FinishTransitionsOnNewOperation \u00b6 All running transitions are abruptly finished when a new one is started QueueOperations \u00b6 The new operation is queued and executed after the current one finishes IgnoreIfThereAreUnfinishedTransitions \u00b6 Runs the new one only if there are no transitions happening currently; ignore and discard it otherwise","title":"Back stack"},{"location":"navmodel/backstack/#back-stack","text":"Implements a simple linear history: The last element at the end of the stack is considered \"active\". All other elements are considered stashed. Children associated with stashed elements are off the screen but kept alive (see how the counter values reflect this on the video) The back stack can never be empty \u2013 it always contains at least one element. The back stack also supports different back press and operation strategies (see further down below).","title":"Back stack"},{"location":"navmodel/backstack/#states","text":"enum class State { CREATED , ACTIVE , STASHED , DESTROYED , }","title":"States"},{"location":"navmodel/backstack/#visualisation-of-states","text":"Check out the apps in our Coding challenges \u2013 they have an embedded visualisation of what happens to all the elements inside the back stack (look at the row of orange boxes below the logo).","title":"Visualisation of states"},{"location":"navmodel/backstack/#constructing-the-back-stack","text":"As the back stack can never be empty, it's required to define an initial target. class BackStack < NavTarget : Any > ( initialElement : NavTarget , savedStateMap : SavedStateMap?, // Optional parameters are omitted )","title":"Constructing the back stack"},{"location":"navmodel/backstack/#default-on-screen-resolution","text":"As a default, only the active element is considered on screen. object BackStackOnScreenResolver : OnScreenStateResolver < State > { override fun isOnScreen ( state : State ): Boolean = when ( state ) { State . CREATED , State . STASHED , State . DESTROYED -> false State . ACTIVE -> true } }","title":"Default on screen resolution"},{"location":"navmodel/backstack/#default-transition-handlers","text":"","title":"Default transition handlers"},{"location":"navmodel/backstack/#backstackfader","text":"rememberBackstackFader() Adds simple cross-fading transitions","title":"BackStackFader"},{"location":"navmodel/backstack/#backstackslider","text":"rememberBackstackSlider() Adds horizontal sliding transitions so that the ACTIVE element is in the center; other states are animated from / to the left or the right edge of the screen.","title":"BackStackSlider"},{"location":"navmodel/backstack/#operations","text":"","title":"Operations"},{"location":"navmodel/backstack/#push","text":"backStack.push(navTarget) Effect on stack: [A, B, C] + Push(D) = [A, B, C, D] Transitions the active element ACTIVE -> STASHED . Adds a new element at the end of the stack with a CREATED -> ACTIVE transition.","title":"Push"},{"location":"navmodel/backstack/#replace","text":"backStack.replace(navTarget) Effect on stack: [A, B, C] + Replace(D) = [A, B, D] Transitions the active element ACTIVE -> DESTROYED , which will be removed when the transition finishes. Adds a new element at the end of the stack with a CREATED -> ACTIVE transition.","title":"Replace"},{"location":"navmodel/backstack/#pop","text":"backStack.pop(navTarget) Effect on stack: [A, B, C] + Pop = [A, B] Transitions the active element ACTIVE -> DESTROYED , which will be removed when the transition finishes. Transitions the last stashed element STASHED -> ACTIVE .","title":"Pop"},{"location":"navmodel/backstack/#single-top","text":"backStack.singleTop(navTarget) Effect on stack: depends on the contents of the stack: [A, B, C, D] + SingleTop(B) = [A, B] // of same type and equals, acts as n * Pop [A, B, C, D] + SingleTop(B') = [A, B'] // of same type but not equals, acts as n * Pop + Replace [A, B, C, D] + SingleTop(E) = [A, B, C, D, E] // not found, acts as Push","title":"Single top"},{"location":"navmodel/backstack/#back-press-strategy","text":"You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class BackStack < NavTarget : Any > ( /* ... */ backPressHandler : BackPressHandlerStrategy < NavTarget , State > = PopBackPressHandler (), /* ... */ )","title":"Back press strategy"},{"location":"navmodel/backstack/#popbackpresshandler","text":"The default back press handling strategy. Runs a Pop operation.","title":"PopBackPressHandler"},{"location":"navmodel/backstack/#donthandlebackpress","text":"Serves as a no-op.","title":"DontHandleBackPress"},{"location":"navmodel/backstack/#operation-strategy","text":"You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class BackStack < NavTarget : Any > ( /* ... */ operationStrategy : OperationStrategy < NavTarget , State > = ExecuteImmediately (), /* ... */ )","title":"Operation strategy"},{"location":"navmodel/backstack/#executeimmediately","text":"The default strategy. New operations are executed without any questions, regardless of any already running transitions.","title":"ExecuteImmediately"},{"location":"navmodel/backstack/#finishtransitionsonnewoperation","text":"All running transitions are abruptly finished when a new one is started","title":"FinishTransitionsOnNewOperation"},{"location":"navmodel/backstack/#queueoperations","text":"The new operation is queued and executed after the current one finishes","title":"QueueOperations"},{"location":"navmodel/backstack/#ignoreifthereareunfinishedtransitions","text":"Runs the new one only if there are no transitions happening currently; ignore and discard it otherwise","title":"IgnoreIfThereAreUnfinishedTransitions"},{"location":"navmodel/cards/","text":"Cards \u00b6 Implements a dating-cards-like mechanism. Intended only as an illustration, but it should be easy enough to tailor it to your needs if you find it useful. Where can I find this NavModel? \u00b6 The Cards NavModel is not currently published, however you can try it in :samples:app . Launch the sample app and check the Dating cards NavModel item to see it in action. States \u00b6 sealed class State { data class Queued ( val queueNumber : Int ) : State () object Bottom : State () object Top : State () object IndicateLike : State () object IndicatePass : State () object VoteLike : State () object VotePass : State () } State transitions \u00b6 Constructing Cards \u00b6 Requires defining items that will be converted to profile cards. The first one in the list will become a Top card, the second one a Bottom card, the rest will be Queued . class Cards < NavTarget : Any > ( initialItems : List < NavTarget > = listOf (), ) : BaseNavModel < NavTarget , State > ( screenResolver = CardsOnScreenResolver , finalStates = FINAL_STATES , savedStateMap = null ) { companion object { internal val FINAL_STATES = setOf ( VoteLike , VotePass ) internal val TOP_STATES = setOf ( Top , IndicateLike , IndicatePass ) } } Default on screen resolution \u00b6 internal object CardsOnScreenResolver : OnScreenStateResolver < State > { override fun isOnScreen ( state : State ): Boolean = when ( state ) { is State . Bottom , is State . Top , is State . IndicateLike , is State . IndicatePass -> true is State . Queued , is State . VoteLike , is State . VotePass -> false } } Default transition handlers \u00b6 CardsTransitionHandler \u00b6 rememberCardsTransitionHandler() Adds scale-up, swipe and rotation animations. Operations \u00b6 PromoteAll \u00b6 Internal operation. Automatically invoked whenever a top card is moved to a vote-related state. Causes all other cards to come forward in the queue, become the Bottom card, then the Top card. IndicateLike, IndicatePass, VoteLike, VotePass \u00b6 Transitions the Top card directly to these states.","title":"Cards"},{"location":"navmodel/cards/#cards","text":"Implements a dating-cards-like mechanism. Intended only as an illustration, but it should be easy enough to tailor it to your needs if you find it useful.","title":"Cards"},{"location":"navmodel/cards/#where-can-i-find-this-navmodel","text":"The Cards NavModel is not currently published, however you can try it in :samples:app . Launch the sample app and check the Dating cards NavModel item to see it in action.","title":"Where can I find this NavModel?"},{"location":"navmodel/cards/#states","text":"sealed class State { data class Queued ( val queueNumber : Int ) : State () object Bottom : State () object Top : State () object IndicateLike : State () object IndicatePass : State () object VoteLike : State () object VotePass : State () }","title":"States"},{"location":"navmodel/cards/#state-transitions","text":"","title":"State transitions"},{"location":"navmodel/cards/#constructing-cards","text":"Requires defining items that will be converted to profile cards. The first one in the list will become a Top card, the second one a Bottom card, the rest will be Queued . class Cards < NavTarget : Any > ( initialItems : List < NavTarget > = listOf (), ) : BaseNavModel < NavTarget , State > ( screenResolver = CardsOnScreenResolver , finalStates = FINAL_STATES , savedStateMap = null ) { companion object { internal val FINAL_STATES = setOf ( VoteLike , VotePass ) internal val TOP_STATES = setOf ( Top , IndicateLike , IndicatePass ) } }","title":"Constructing Cards"},{"location":"navmodel/cards/#default-on-screen-resolution","text":"internal object CardsOnScreenResolver : OnScreenStateResolver < State > { override fun isOnScreen ( state : State ): Boolean = when ( state ) { is State . Bottom , is State . Top , is State . IndicateLike , is State . IndicatePass -> true is State . Queued , is State . VoteLike , is State . VotePass -> false } }","title":"Default on screen resolution"},{"location":"navmodel/cards/#default-transition-handlers","text":"","title":"Default transition handlers"},{"location":"navmodel/cards/#cardstransitionhandler","text":"rememberCardsTransitionHandler() Adds scale-up, swipe and rotation animations.","title":"CardsTransitionHandler"},{"location":"navmodel/cards/#operations","text":"","title":"Operations"},{"location":"navmodel/cards/#promoteall","text":"Internal operation. Automatically invoked whenever a top card is moved to a vote-related state. Causes all other cards to come forward in the queue, become the Bottom card, then the Top card.","title":"PromoteAll"},{"location":"navmodel/cards/#indicatelike-indicatepass-votelike-votepass","text":"Transitions the Top card directly to these states.","title":"IndicateLike, IndicatePass, VoteLike, VotePass"},{"location":"navmodel/custom/","text":"Implementing your own navigation models \u00b6 A step-by-step guide. You can also take a look at other existing examples to see these in practice. Step 1 \u00b6 Create the class; define your possible states; define your initial state. class Foo < NavTarget : Any > ( initialItems : List < NavTarget > = listOf (), savedStateMap : SavedStateMap? ) : BaseNavModel < NavTarget , Foo . State > ( screenResolver = FooOnScreenResolver , // We'll see about this shortly finalState = DESTROYED , // Anything transitioning towards this state will be discarded eventually savedStateMap = savedStateMap // It's nullable if you don't need state restoration ) { // Your possible states for any single navigation target enum class State { CREATED , FOO , BAR , BAZ , DESTROYED ; } // You can go about it any other way. // Back stack for example defines only a single element. // Here we take all the <NavTarget> elements and make them transition CREATED -> FOO immediately. override val initialElements = initialItems . map { FooElement ( key = NavKey ( it ), fromState = State . CREATED , targetState = State . FOO , operation = Operation . Noop () ) } } (optional) Step 2 \u00b6 Add some convenience aliases: typealias FooElement < NavTarget > = NavElement < NavTarget , Foo . State > typealias FooElements < NavTarget > = NavElements < NavTarget , Foo . State > sealed interface FooOperation < NavTarget > : Operation < NavTarget , Foo . State > Step 3 \u00b6 Define one or more operations. @Parcelize class SomeOperation < NavTarget : Any > : FooOperation < NavTarget > { override fun isApplicable ( elements : FooElements < NavTarget > ): Boolean = TODO ( \"Define whether this operation is applicable given the current state\" ) override fun invoke ( elements : FooElements < NavTarget > , ): NavElements < NavTarget , Foo . State > = // TODO: Mutate elements however you please. Add, remove, change. // In this example we're changing all elements to transition to BAR. // You can also use helper methods elements.transitionTo & elements.transitionToIndexed elements . map { it . transitionTo ( newTargetState = BAR , operation = this ) } } // You can add an extension method for a leaner API fun < NavTarget : Any > Foo < NavTarget > . someOperation () { accept ( FooOperation ()) } Step 4 \u00b6 Add the screen resolver to define which states should be / should not be part of the composition in the end: object FooOnScreenResolver : OnScreenStateResolver < State > { override fun isOnScreen ( state : State ): Boolean = when ( state ) { Foo . State . CREATED , Foo . State . DESTROYED -> false Foo . State . FOO , Foo . State . BAR , Foo . State . BAZ , -> true } } Step 5 \u00b6 Add one or more transition handlers to interpret different states and translate them to Jetpack Compose Modifiers . class FooTransitionHandler < NavTarget > ( private val transitionSpec : TransitionSpec < Foo . State , Float > = { spring () } ) : ModifierTransitionHandler < NavTarget , Foo . State > () { // TODO define a Modifier depending on the state. // Here we'll just mutate scaling: override fun createModifier ( modifier : Modifier , transition : Transition < Foo . State > , descriptor : TransitionDescriptor < NavTarget , Foo . State > ): Modifier = modifier . composed { val scale = transition . animateFloat ( transitionSpec = transitionSpec , targetValueByState = { when ( it ) { Foo . State . CREATED -> 0f Foo . State . FOO -> 0.33f Foo . State . BAR -> 0.66f Foo . State . BAZ -> 1.0f Foo . State . DESTROYED -> 0f } }) scale ( scale . value ) } } // TODO remember to add: @Composable fun < NavTarget > rememberFooTransitionHandler ( transitionSpec : TransitionSpec < Foo . State , Float > = { spring () } ): ModifierTransitionHandler < NavTarget , Foo . State > = remember { FooTransitionHandler ( transitionSpec ) } Test it \u00b6 Add Children to your Node . Pass your NavModel and the transition handler: @Composable override fun View ( modifier : Modifier ) { Children ( modifier = Modifier . fillMaxSize (), navModel = foo , transitionHandler = rememberFooTransitionHandler () ) } Somewhere else in your business logic trigger the operations you defined. Make sure they're called on the same foo instance that you pass to the Children composable: foo . someOperation () As soon as this is triggered, elements should transition to the BAR state in this example, and you should see them scale up defined by the transition handler. Created something cool? \u00b6 Let us know!","title":"Writing your own"},{"location":"navmodel/custom/#implementing-your-own-navigation-models","text":"A step-by-step guide. You can also take a look at other existing examples to see these in practice.","title":"Implementing your own navigation models"},{"location":"navmodel/custom/#step-1","text":"Create the class; define your possible states; define your initial state. class Foo < NavTarget : Any > ( initialItems : List < NavTarget > = listOf (), savedStateMap : SavedStateMap? ) : BaseNavModel < NavTarget , Foo . State > ( screenResolver = FooOnScreenResolver , // We'll see about this shortly finalState = DESTROYED , // Anything transitioning towards this state will be discarded eventually savedStateMap = savedStateMap // It's nullable if you don't need state restoration ) { // Your possible states for any single navigation target enum class State { CREATED , FOO , BAR , BAZ , DESTROYED ; } // You can go about it any other way. // Back stack for example defines only a single element. // Here we take all the <NavTarget> elements and make them transition CREATED -> FOO immediately. override val initialElements = initialItems . map { FooElement ( key = NavKey ( it ), fromState = State . CREATED , targetState = State . FOO , operation = Operation . Noop () ) } }","title":"Step 1"},{"location":"navmodel/custom/#optional-step-2","text":"Add some convenience aliases: typealias FooElement < NavTarget > = NavElement < NavTarget , Foo . State > typealias FooElements < NavTarget > = NavElements < NavTarget , Foo . State > sealed interface FooOperation < NavTarget > : Operation < NavTarget , Foo . State >","title":"(optional) Step 2"},{"location":"navmodel/custom/#step-3","text":"Define one or more operations. @Parcelize class SomeOperation < NavTarget : Any > : FooOperation < NavTarget > { override fun isApplicable ( elements : FooElements < NavTarget > ): Boolean = TODO ( \"Define whether this operation is applicable given the current state\" ) override fun invoke ( elements : FooElements < NavTarget > , ): NavElements < NavTarget , Foo . State > = // TODO: Mutate elements however you please. Add, remove, change. // In this example we're changing all elements to transition to BAR. // You can also use helper methods elements.transitionTo & elements.transitionToIndexed elements . map { it . transitionTo ( newTargetState = BAR , operation = this ) } } // You can add an extension method for a leaner API fun < NavTarget : Any > Foo < NavTarget > . someOperation () { accept ( FooOperation ()) }","title":"Step 3"},{"location":"navmodel/custom/#step-4","text":"Add the screen resolver to define which states should be / should not be part of the composition in the end: object FooOnScreenResolver : OnScreenStateResolver < State > { override fun isOnScreen ( state : State ): Boolean = when ( state ) { Foo . State . CREATED , Foo . State . DESTROYED -> false Foo . State . FOO , Foo . State . BAR , Foo . State . BAZ , -> true } }","title":"Step 4"},{"location":"navmodel/custom/#step-5","text":"Add one or more transition handlers to interpret different states and translate them to Jetpack Compose Modifiers . class FooTransitionHandler < NavTarget > ( private val transitionSpec : TransitionSpec < Foo . State , Float > = { spring () } ) : ModifierTransitionHandler < NavTarget , Foo . State > () { // TODO define a Modifier depending on the state. // Here we'll just mutate scaling: override fun createModifier ( modifier : Modifier , transition : Transition < Foo . State > , descriptor : TransitionDescriptor < NavTarget , Foo . State > ): Modifier = modifier . composed { val scale = transition . animateFloat ( transitionSpec = transitionSpec , targetValueByState = { when ( it ) { Foo . State . CREATED -> 0f Foo . State . FOO -> 0.33f Foo . State . BAR -> 0.66f Foo . State . BAZ -> 1.0f Foo . State . DESTROYED -> 0f } }) scale ( scale . value ) } } // TODO remember to add: @Composable fun < NavTarget > rememberFooTransitionHandler ( transitionSpec : TransitionSpec < Foo . State , Float > = { spring () } ): ModifierTransitionHandler < NavTarget , Foo . State > = remember { FooTransitionHandler ( transitionSpec ) }","title":"Step 5"},{"location":"navmodel/custom/#test-it","text":"Add Children to your Node . Pass your NavModel and the transition handler: @Composable override fun View ( modifier : Modifier ) { Children ( modifier = Modifier . fillMaxSize (), navModel = foo , transitionHandler = rememberFooTransitionHandler () ) } Somewhere else in your business logic trigger the operations you defined. Make sure they're called on the same foo instance that you pass to the Children composable: foo . someOperation () As soon as this is triggered, elements should transition to the BAR state in this example, and you should see them scale up defined by the transition handler.","title":"Test it"},{"location":"navmodel/custom/#created-something-cool","text":"Let us know!","title":"Created something cool?"},{"location":"navmodel/promoter/","text":"Promoter carousel \u00b6 Intended only as an illustration. Where can I find this NavModel? \u00b6 The Promoter NavModel is not currently published, however you can fork the Appyx repository and try it out yourself! If you feel that this functionality should be part of the main library, please let us know. States \u00b6 enum class State { CREATED , STAGE1 , STAGE2 , STAGE3 , STAGE4 , SELECTED , DESTROYED } Default on screen resolution \u00b6 internal object PromoterOnScreenResolver : OnScreenStateResolver < State > { override fun isOnScreen ( state : State ): Boolean = when ( state ) { State . DESTROYED -> false else -> true } } Default transition handler \u00b6 As elements are promoted to next stages, they're: animated on a circular path scaled up rotated in the selection / discard stages You can check PromoterTransitionHandler for implementation details. Operations \u00b6 Add first \u00b6 promoter.addFirst(navTarget) Adds a new element at the start of the element list with a CREATED state. Promote all \u00b6 promoter.promoteAll() All elements are transitioned to the next state: CREATED -> STAGE1 STAGE1 -> STAGE2 STAGE2 -> STAGE3 STAGE3 -> STAGE4 STAGE4 -> SELECTED SELECTED -> DESTROYED","title":"Promoter"},{"location":"navmodel/promoter/#promoter-carousel","text":"Intended only as an illustration.","title":"Promoter carousel"},{"location":"navmodel/promoter/#where-can-i-find-this-navmodel","text":"The Promoter NavModel is not currently published, however you can fork the Appyx repository and try it out yourself! If you feel that this functionality should be part of the main library, please let us know.","title":"Where can I find this NavModel?"},{"location":"navmodel/promoter/#states","text":"enum class State { CREATED , STAGE1 , STAGE2 , STAGE3 , STAGE4 , SELECTED , DESTROYED }","title":"States"},{"location":"navmodel/promoter/#default-on-screen-resolution","text":"internal object PromoterOnScreenResolver : OnScreenStateResolver < State > { override fun isOnScreen ( state : State ): Boolean = when ( state ) { State . DESTROYED -> false else -> true } }","title":"Default on screen resolution"},{"location":"navmodel/promoter/#default-transition-handler","text":"As elements are promoted to next stages, they're: animated on a circular path scaled up rotated in the selection / discard stages You can check PromoterTransitionHandler for implementation details.","title":"Default transition handler"},{"location":"navmodel/promoter/#operations","text":"","title":"Operations"},{"location":"navmodel/promoter/#add-first","text":"promoter.addFirst(navTarget) Adds a new element at the start of the element list with a CREATED state.","title":"Add first"},{"location":"navmodel/promoter/#promote-all","text":"promoter.promoteAll() All elements are transitioned to the next state: CREATED -> STAGE1 STAGE1 -> STAGE2 STAGE2 -> STAGE3 STAGE3 -> STAGE4 STAGE4 -> SELECTED SELECTED -> DESTROYED","title":"Promote all"},{"location":"navmodel/spotlight/","text":"Spotlight \u00b6 Implements a mechanism analogous to a view pager; has a single active element (\"it's in the spotlight\", hence the name), but unlike the back stack, it does not remove other elements. It's great for flows or tabbed containers. States \u00b6 enum class State { INACTIVE_BEFORE , ACTIVE , INACTIVE_AFTER ; } Constructing spotlight \u00b6 Requires defining items and an active index. class Spotlight < NavTarget : Any > ( items : List < NavTarget > , initialActiveIndex : Int = 0 , savedStateMap : SavedStateMap?, // Optional parameters are omitted ) Default on screen resolution \u00b6 As a default, only the active element is considered on screen. object SpotlightOnScreenResolver : OnScreenStateResolver < Spotlight . State > { override fun isOnScreen ( state : Spotlight . State ): Boolean = when ( state ) { Spotlight . State . INACTIVE_BEFORE , Spotlight . State . INACTIVE_AFTER -> false Spotlight . State . ACTIVE -> true } } Default transition handlers \u00b6 SpotlightFader \u00b6 rememberSpotlightFader() Adds simple cross-fading transitions SpotlightSlider \u00b6 rememberSpotlightSlider() Adds horizontal sliding transitions so that the ACTIVE element is in the center; other states are animated from / to the left or the right edge of the screen, depending on the order of them in the items property. Operations \u00b6 Activate \u00b6 spotlight.activate(navTarget) Transitions the element to ACTIVE . Transitions other elements to INACTIVE_BEFORE or INACTIVE_AFTER depending on their relative position to the activated element. Next \u00b6 spotlight.next() Transitions the currently active element to INACTIVE_BEFORE . Transitions the element after the currently active one to ACTIVE . Previous \u00b6 spotlight.previous() Transitions the currently active element to INACTIVE_AFTER . Transitions the element before the currently active one to ACTIVE . Update elements \u00b6 spotlight.updateElements(items, activeIndex) Replaces elements held by the spotlight instance with a new list. Transitions new elements to INACTIVE_BEFORE , ACTIVE , or INACTIVE_AFTER depending on their position in the provided list relative to activeIndex . Back press strategy \u00b6 You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class Spotlight < NavTarget : Any > ( /* ... */ backPressHandler : BackPressHandlerStrategy < NavTarget , State > = GoToDefault ( initialActiveIndex ) /* ... */ ) GoToDefault \u00b6 The default back press handling strategy. Activates the default index. GoToPrevious \u00b6 Runs a Previous operation. Operation strategy \u00b6 You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class Spotlight < NavTarget : Any > ( /* ... */ operationStrategy : OperationStrategy < NavTarget , State > = ExecuteImmediately (), /* ... */ ) ExecuteImmediately \u00b6 The default strategy. New operations are executed without any questions, regardless of any already running transitions.","title":"Spotlight"},{"location":"navmodel/spotlight/#spotlight","text":"Implements a mechanism analogous to a view pager; has a single active element (\"it's in the spotlight\", hence the name), but unlike the back stack, it does not remove other elements. It's great for flows or tabbed containers.","title":"Spotlight"},{"location":"navmodel/spotlight/#states","text":"enum class State { INACTIVE_BEFORE , ACTIVE , INACTIVE_AFTER ; }","title":"States"},{"location":"navmodel/spotlight/#constructing-spotlight","text":"Requires defining items and an active index. class Spotlight < NavTarget : Any > ( items : List < NavTarget > , initialActiveIndex : Int = 0 , savedStateMap : SavedStateMap?, // Optional parameters are omitted )","title":"Constructing spotlight"},{"location":"navmodel/spotlight/#default-on-screen-resolution","text":"As a default, only the active element is considered on screen. object SpotlightOnScreenResolver : OnScreenStateResolver < Spotlight . State > { override fun isOnScreen ( state : Spotlight . State ): Boolean = when ( state ) { Spotlight . State . INACTIVE_BEFORE , Spotlight . State . INACTIVE_AFTER -> false Spotlight . State . ACTIVE -> true } }","title":"Default on screen resolution"},{"location":"navmodel/spotlight/#default-transition-handlers","text":"","title":"Default transition handlers"},{"location":"navmodel/spotlight/#spotlightfader","text":"rememberSpotlightFader() Adds simple cross-fading transitions","title":"SpotlightFader"},{"location":"navmodel/spotlight/#spotlightslider","text":"rememberSpotlightSlider() Adds horizontal sliding transitions so that the ACTIVE element is in the center; other states are animated from / to the left or the right edge of the screen, depending on the order of them in the items property.","title":"SpotlightSlider"},{"location":"navmodel/spotlight/#operations","text":"","title":"Operations"},{"location":"navmodel/spotlight/#activate","text":"spotlight.activate(navTarget) Transitions the element to ACTIVE . Transitions other elements to INACTIVE_BEFORE or INACTIVE_AFTER depending on their relative position to the activated element.","title":"Activate"},{"location":"navmodel/spotlight/#next","text":"spotlight.next() Transitions the currently active element to INACTIVE_BEFORE . Transitions the element after the currently active one to ACTIVE .","title":"Next"},{"location":"navmodel/spotlight/#previous","text":"spotlight.previous() Transitions the currently active element to INACTIVE_AFTER . Transitions the element before the currently active one to ACTIVE .","title":"Previous"},{"location":"navmodel/spotlight/#update-elements","text":"spotlight.updateElements(items, activeIndex) Replaces elements held by the spotlight instance with a new list. Transitions new elements to INACTIVE_BEFORE , ACTIVE , or INACTIVE_AFTER depending on their position in the provided list relative to activeIndex .","title":"Update elements"},{"location":"navmodel/spotlight/#back-press-strategy","text":"You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class Spotlight < NavTarget : Any > ( /* ... */ backPressHandler : BackPressHandlerStrategy < NavTarget , State > = GoToDefault ( initialActiveIndex ) /* ... */ )","title":"Back press strategy"},{"location":"navmodel/spotlight/#gotodefault","text":"The default back press handling strategy. Activates the default index.","title":"GoToDefault"},{"location":"navmodel/spotlight/#gotoprevious","text":"Runs a Previous operation.","title":"GoToPrevious"},{"location":"navmodel/spotlight/#operation-strategy","text":"You can override the default strategy in the constructor. You're not limited to using the provided classes, feel free to implement your own. class Spotlight < NavTarget : Any > ( /* ... */ operationStrategy : OperationStrategy < NavTarget , State > = ExecuteImmediately (), /* ... */ )","title":"Operation strategy"},{"location":"navmodel/spotlight/#executeimmediately","text":"The default strategy. New operations are executed without any questions, regardless of any already running transitions.","title":"ExecuteImmediately"},{"location":"navmodel/tiles/","text":"Tiles \u00b6 Intended only as an illustration, but it should be easy enough to tailor it to your needs if you find it useful. Where can I find this NavModel? \u00b6 The Tiles NavModel is not currently published, however you can fork the Appyx repository and try it out yourself! If you feel that this functionality should be part of the main library, please let us know. States \u00b6 enum class State { CREATED , STANDARD , SELECTED , DESTROYED } Default on screen resolution \u00b6 internal object TilesOnScreenResolver : OnScreenStateResolver < State > { override fun isOnScreen ( state : State ): Boolean = when ( state ) { State . CREATED , State . STANDARD , State . SELECTED -> true State . DESTROYED -> false } } Default transition handler \u00b6 Selection translates to scaling. Destroying makes elements fly off the screen with rotation and downscaling. Operations \u00b6 Add \u00b6 tiles.add(navTarget) Adds a new element to the NavModel immediately transitioning from CREATED -> STANDARD . Destroy \u00b6 tiles.destroy(navTarget) Transitions a given element to DESTROYED . Select \u00b6 tiles.select(navTarget) Transitions a given element STANDARD -> SELECTED . Deselect \u00b6 tiles.deselect(navTarget) Transitions a given element SELECTED -> STANDARD . Deselect all \u00b6 tiles.deselectAll() Transitions all elements SELECTED -> STANDARD . Remove selected \u00b6 tiles.removeSelected() Transitions all elements that have SELECTED state to DESTROYED .","title":"Tiles"},{"location":"navmodel/tiles/#tiles","text":"Intended only as an illustration, but it should be easy enough to tailor it to your needs if you find it useful.","title":"Tiles"},{"location":"navmodel/tiles/#where-can-i-find-this-navmodel","text":"The Tiles NavModel is not currently published, however you can fork the Appyx repository and try it out yourself! If you feel that this functionality should be part of the main library, please let us know.","title":"Where can I find this NavModel?"},{"location":"navmodel/tiles/#states","text":"enum class State { CREATED , STANDARD , SELECTED , DESTROYED }","title":"States"},{"location":"navmodel/tiles/#default-on-screen-resolution","text":"internal object TilesOnScreenResolver : OnScreenStateResolver < State > { override fun isOnScreen ( state : State ): Boolean = when ( state ) { State . CREATED , State . STANDARD , State . SELECTED -> true State . DESTROYED -> false } }","title":"Default on screen resolution"},{"location":"navmodel/tiles/#default-transition-handler","text":"Selection translates to scaling. Destroying makes elements fly off the screen with rotation and downscaling.","title":"Default transition handler"},{"location":"navmodel/tiles/#operations","text":"","title":"Operations"},{"location":"navmodel/tiles/#add","text":"tiles.add(navTarget) Adds a new element to the NavModel immediately transitioning from CREATED -> STANDARD .","title":"Add"},{"location":"navmodel/tiles/#destroy","text":"tiles.destroy(navTarget) Transitions a given element to DESTROYED .","title":"Destroy"},{"location":"navmodel/tiles/#select","text":"tiles.select(navTarget) Transitions a given element STANDARD -> SELECTED .","title":"Select"},{"location":"navmodel/tiles/#deselect","text":"tiles.deselect(navTarget) Transitions a given element SELECTED -> STANDARD .","title":"Deselect"},{"location":"navmodel/tiles/#deselect-all","text":"tiles.deselectAll() Transitions all elements SELECTED -> STANDARD .","title":"Deselect all"},{"location":"navmodel/tiles/#remove-selected","text":"tiles.removeSelected() Transitions all elements that have SELECTED state to DESTROYED .","title":"Remove selected"},{"location":"releases/changelog/","text":"Changelog \u00b6 Pending changes \u00b6 #287 \u2013 Added : Introduced a new rememberCombinedHandler implementation that takes an immutable list to avoid non-skippable compositions. The previous implementation is now deprecated. #287 \u2013 Added : ImmutableList has been added to avoid non-skippable compositions. #289 \u2013 Added : Introduced interop-rx3 for RxJava 3 support. This has identical functionality to interop-rx2 . #298 \u2013 Updated : ChildView documentation. TransitionDescriptor generics has been renamed to NavTarget and State 1.0.1 \u00b6 #268 \u2013 Fixed : PermanentChild now does not crash in UI tests with ComposeTestRule . #276 \u2013 Fixed : Back press handlers order is fixed for RIBs-Appyx integration. #272 \u2013 Changed : attachWorkflow renamed to attachChild . executeWorkflow renamed to executeAction . #272 \u2013 Added : NodeReadyObserver plugin to observe when the Node is ready 22 Nov 2022 1.0.0 \u00b6 #247 \u2013 Added : Added EmptyNavModel to core for cases in which a ParentNode only uses PermanentChild . The DummyNavModel test class is deprecated. #250 \u2013 Updated : Jetpack Compose to 1.3.0 31 Oct 2022 1.0.0-rc02 \u00b6 #231 \u2013 Fixed : Changing transition handler at runtime does not redraw children #239 \u2013 Fixed : Fixed an issue with desynchronisation between NavModel and children's restoration process #218 \u2013 Updated : androidx.core:core-ktx to 1.9.0. 21 Oct 2022 1.0.0-rc01 \u00b6 #214 \u2013 Breaking change : AppyxViewTestRule stops supporting automatic launching activity. Activities should be started explicitly in tests. #197 \u2013 Breaking change : ParentNodeView does not implement plugin anymore. Node instance is retrieved via LocalComposition . AppyxParentViewTestRule and AbstractParentNodeView have been removed. #196 \u2013 Breaking change : InteropBuilder now should be supplied with Appyx IntegrationPointProvider to attach it at the same time Appyx Node is created. #185 \u2013 Breaking change : Activity must implement IntegrationPointProvider and create IntegrationPoint manually. Weak references usage has been removed. #173 \u2013 Breaking change : ActivityStarter and PermissionRequester now exposes coroutine based API instead of minimal.reactive . #200 \u2013 Breaking change : Reordered the parameters for ParentNode<NavTarget>.Child and fun <N : Node> NodeHost to meet Compose guidelines. #43 \u2013 Updated : Jetpack Compose to 1.2.1 and Kotlin to 1.7.10 . #168 \u2013 Updated : Kotlin coroutines to 1.6.4 . #171 \u2013 Updated : RIBs to 0.36.1 . #212 \u2013 Updated : Node parent property is now public instead of private. #174 \u2013 Fixed : IntegrationPointExample does not work with \"do not keep activities\" #180 \u2013 Added : Ensure that super.onSaveInstanceState() was called to restore Node's state correctly 13 Oct 2022 1.0-alpha09 \u00b6 #151 - Breaking change : Renamed Routing to NavTarget . All related namings are affected ( RoutingElement , RoutingKey , etc.) #158 - Breaking change : Renamed TransitionState to State in all NavModel impls. Renamed STASHED_IN_BACK_STACK to STASHED . #146 - Breaking change : Removed FragmentIntegrationPoint . Clients should use ActivityIntegrationPoint.getIntegrationPoint(context: Context) to get integration point from Fragment #160 - Breaking change : Renamed navmodel-addons to navmodel-samples and stopped publishing the binary. If you feel we should add any of the samples to the main codebase, please let us know! #138 - Fixed : androidx.appcompat:appcompat from is exposed via api within com.bumble.appyx:core . This prevents potential compilation bugs. #143 - Fixed : Correctly exposed transitive dependencies that are part of the libraries ABI #162 - Fixed : NodeTestHelper 's moveTo function can now move to Lifecycle.State.DESTROYED . The node itself has safeguards to prevent moving from destroyed state, and moving to destroyed is a valid test case. #145 - Updated : SpotlightSlider now uses offset modifier with lambda #159 - Added : NodeHost now takes modifier parameter to decorate the view of a root node #162 - Added : disposeOnDestroyPlugin extension has been added to interop-rx2. This will allow Rx2 code to be easily disposed when the node it belongs to is destroyed. #161 - Added : Operations helpers 22 Sep 2022 1.0-alpha08 \u00b6 #140 - Breaking change : Added testing-ui-activity module to avoid needing to add testing-ui as a debug implementation as part of instrumentation testing. See the linked issue for more details #139 - Fixed : IntegrationPoint memory leak created by ActivityIntegrationPoint 12 Sep 2022 1.0-alpha07 \u00b6 #122 - Breaking change : ChildEntry.ChildMode is removed, now nodes are always created when a nav model changes (previously default behaviour) #99 \u2013 Breaking change : Removed IntegrationPointAppyxProvider and made ActivityIntegrationPoint 's constructor private. Use ActivityIntegrationPoint.createIntegrationPoint . This uses a weak reference to keep track of the integration points, and will not introduce memory leaks. #122 - Added : New ChildEntry.KeepMode that allows to destroy nodes that are currently not visible on the screen #132 - Added : New NodeComponentActivity to extend when wanting to work with ComponentActivity as your base activity, eg when migrating from a project built from the Jetpack Compose template #119 - Fixed : Lifecycle observers are invoked in incorrect order (child before parent) #62 - Fixed : Node is marked with stable annotation making some of the composable functions skippable #129 - Updated : Removed sealed interface from operations to allow client to define their own #133 - Updated : NodeView interface and ParentNode marked as stable improving amount of skippable composables 9 Sep 2022 1.0-alpha06 \u00b6 #96 \u2013 Breaking change : Removed InteractorTestHelper . Please use Node tests instead of Interactor tests. #99 \u2013 Breaking change : Modified package of NodeConnector and Connectable #99 \u2013 Added : Source .rx2() to convert Source to io.reactivex.Observable #107 \u2013 Fixed : Back press handlers are not properly registered on lifecycle events 26 Aug 2022 1.0-alpha05 \u00b6 #83 \u2013 Breaking change : RoutingSource renamed to NavModel . All subclasses, fields, package names, etc., any mentions of the word follow suit. #91 \u2013 Fixed : Spotlight next and previous operations crash fix 19 Aug 2022 1.0-alpha04 \u00b6 #39 \u2013 Added : Workflows implementation to support deeplinks #32 \u2013 Added : BackPressHandler plugin that allows to control back press behaviour via androidx.activity.OnBackPressedCallback #59 \u2013 Added : interface for ParentNodeView<> #32 \u2013 Added : Jetpack Compose Navigation code sample #81 \u2013 Added : Support integration point for multiple roots #65 \u2013 Added : InteropBuilderStub and InteropSimpleBuilderStub testing util classes #47 \u2013 Updated : The customisations module is now pure Java/Kotlin. #85 \u2013 Updated : Improved InteropView error messaging when Activity does not implement IntegrationPointAppyxProvider #88 \u2013 Updated : Moved TestUpNavigationHandler to testing-unit-common 18 Aug 2022 1.0-alpha03 \u00b6 #38 \u2013 Added : JUnit5 support 2 Aug 2022 1.0-alpha02 \u00b6 #19 \u2013 Fixed : Do not allow setting Node.integrationPoint on non-root nodes #23 \u2013 Fixed : Integration point attached twice crash when using live literals #14 \u2013 Fixed : Transition interruptions bug #23 \u2013 Added : Unit test support #26 \u2013 Added : Publish snapshot versions #9 \u2013 Migrated : app-tree-utils into this repository 19 Jul 2022 1.0-alpha01 \u00b6 Initial release 4 Jul 2022","title":"Changelog"},{"location":"releases/changelog/#changelog","text":"","title":"Changelog"},{"location":"releases/changelog/#pending-changes","text":"#287 \u2013 Added : Introduced a new rememberCombinedHandler implementation that takes an immutable list to avoid non-skippable compositions. The previous implementation is now deprecated. #287 \u2013 Added : ImmutableList has been added to avoid non-skippable compositions. #289 \u2013 Added : Introduced interop-rx3 for RxJava 3 support. This has identical functionality to interop-rx2 . #298 \u2013 Updated : ChildView documentation. TransitionDescriptor generics has been renamed to NavTarget and State","title":"Pending changes"},{"location":"releases/changelog/#101","text":"#268 \u2013 Fixed : PermanentChild now does not crash in UI tests with ComposeTestRule . #276 \u2013 Fixed : Back press handlers order is fixed for RIBs-Appyx integration. #272 \u2013 Changed : attachWorkflow renamed to attachChild . executeWorkflow renamed to executeAction . #272 \u2013 Added : NodeReadyObserver plugin to observe when the Node is ready 22 Nov 2022","title":"1.0.1"},{"location":"releases/changelog/#100","text":"#247 \u2013 Added : Added EmptyNavModel to core for cases in which a ParentNode only uses PermanentChild . The DummyNavModel test class is deprecated. #250 \u2013 Updated : Jetpack Compose to 1.3.0 31 Oct 2022","title":"1.0.0"},{"location":"releases/changelog/#100-rc02","text":"#231 \u2013 Fixed : Changing transition handler at runtime does not redraw children #239 \u2013 Fixed : Fixed an issue with desynchronisation between NavModel and children's restoration process #218 \u2013 Updated : androidx.core:core-ktx to 1.9.0. 21 Oct 2022","title":"1.0.0-rc02"},{"location":"releases/changelog/#100-rc01","text":"#214 \u2013 Breaking change : AppyxViewTestRule stops supporting automatic launching activity. Activities should be started explicitly in tests. #197 \u2013 Breaking change : ParentNodeView does not implement plugin anymore. Node instance is retrieved via LocalComposition . AppyxParentViewTestRule and AbstractParentNodeView have been removed. #196 \u2013 Breaking change : InteropBuilder now should be supplied with Appyx IntegrationPointProvider to attach it at the same time Appyx Node is created. #185 \u2013 Breaking change : Activity must implement IntegrationPointProvider and create IntegrationPoint manually. Weak references usage has been removed. #173 \u2013 Breaking change : ActivityStarter and PermissionRequester now exposes coroutine based API instead of minimal.reactive . #200 \u2013 Breaking change : Reordered the parameters for ParentNode<NavTarget>.Child and fun <N : Node> NodeHost to meet Compose guidelines. #43 \u2013 Updated : Jetpack Compose to 1.2.1 and Kotlin to 1.7.10 . #168 \u2013 Updated : Kotlin coroutines to 1.6.4 . #171 \u2013 Updated : RIBs to 0.36.1 . #212 \u2013 Updated : Node parent property is now public instead of private. #174 \u2013 Fixed : IntegrationPointExample does not work with \"do not keep activities\" #180 \u2013 Added : Ensure that super.onSaveInstanceState() was called to restore Node's state correctly 13 Oct 2022","title":"1.0.0-rc01"},{"location":"releases/changelog/#10-alpha09","text":"#151 - Breaking change : Renamed Routing to NavTarget . All related namings are affected ( RoutingElement , RoutingKey , etc.) #158 - Breaking change : Renamed TransitionState to State in all NavModel impls. Renamed STASHED_IN_BACK_STACK to STASHED . #146 - Breaking change : Removed FragmentIntegrationPoint . Clients should use ActivityIntegrationPoint.getIntegrationPoint(context: Context) to get integration point from Fragment #160 - Breaking change : Renamed navmodel-addons to navmodel-samples and stopped publishing the binary. If you feel we should add any of the samples to the main codebase, please let us know! #138 - Fixed : androidx.appcompat:appcompat from is exposed via api within com.bumble.appyx:core . This prevents potential compilation bugs. #143 - Fixed : Correctly exposed transitive dependencies that are part of the libraries ABI #162 - Fixed : NodeTestHelper 's moveTo function can now move to Lifecycle.State.DESTROYED . The node itself has safeguards to prevent moving from destroyed state, and moving to destroyed is a valid test case. #145 - Updated : SpotlightSlider now uses offset modifier with lambda #159 - Added : NodeHost now takes modifier parameter to decorate the view of a root node #162 - Added : disposeOnDestroyPlugin extension has been added to interop-rx2. This will allow Rx2 code to be easily disposed when the node it belongs to is destroyed. #161 - Added : Operations helpers 22 Sep 2022","title":"1.0-alpha09"},{"location":"releases/changelog/#10-alpha08","text":"#140 - Breaking change : Added testing-ui-activity module to avoid needing to add testing-ui as a debug implementation as part of instrumentation testing. See the linked issue for more details #139 - Fixed : IntegrationPoint memory leak created by ActivityIntegrationPoint 12 Sep 2022","title":"1.0-alpha08"},{"location":"releases/changelog/#10-alpha07","text":"#122 - Breaking change : ChildEntry.ChildMode is removed, now nodes are always created when a nav model changes (previously default behaviour) #99 \u2013 Breaking change : Removed IntegrationPointAppyxProvider and made ActivityIntegrationPoint 's constructor private. Use ActivityIntegrationPoint.createIntegrationPoint . This uses a weak reference to keep track of the integration points, and will not introduce memory leaks. #122 - Added : New ChildEntry.KeepMode that allows to destroy nodes that are currently not visible on the screen #132 - Added : New NodeComponentActivity to extend when wanting to work with ComponentActivity as your base activity, eg when migrating from a project built from the Jetpack Compose template #119 - Fixed : Lifecycle observers are invoked in incorrect order (child before parent) #62 - Fixed : Node is marked with stable annotation making some of the composable functions skippable #129 - Updated : Removed sealed interface from operations to allow client to define their own #133 - Updated : NodeView interface and ParentNode marked as stable improving amount of skippable composables 9 Sep 2022","title":"1.0-alpha07"},{"location":"releases/changelog/#10-alpha06","text":"#96 \u2013 Breaking change : Removed InteractorTestHelper . Please use Node tests instead of Interactor tests. #99 \u2013 Breaking change : Modified package of NodeConnector and Connectable #99 \u2013 Added : Source .rx2() to convert Source to io.reactivex.Observable #107 \u2013 Fixed : Back press handlers are not properly registered on lifecycle events 26 Aug 2022","title":"1.0-alpha06"},{"location":"releases/changelog/#10-alpha05","text":"#83 \u2013 Breaking change : RoutingSource renamed to NavModel . All subclasses, fields, package names, etc., any mentions of the word follow suit. #91 \u2013 Fixed : Spotlight next and previous operations crash fix 19 Aug 2022","title":"1.0-alpha05"},{"location":"releases/changelog/#10-alpha04","text":"#39 \u2013 Added : Workflows implementation to support deeplinks #32 \u2013 Added : BackPressHandler plugin that allows to control back press behaviour via androidx.activity.OnBackPressedCallback #59 \u2013 Added : interface for ParentNodeView<> #32 \u2013 Added : Jetpack Compose Navigation code sample #81 \u2013 Added : Support integration point for multiple roots #65 \u2013 Added : InteropBuilderStub and InteropSimpleBuilderStub testing util classes #47 \u2013 Updated : The customisations module is now pure Java/Kotlin. #85 \u2013 Updated : Improved InteropView error messaging when Activity does not implement IntegrationPointAppyxProvider #88 \u2013 Updated : Moved TestUpNavigationHandler to testing-unit-common 18 Aug 2022","title":"1.0-alpha04"},{"location":"releases/changelog/#10-alpha03","text":"#38 \u2013 Added : JUnit5 support 2 Aug 2022","title":"1.0-alpha03"},{"location":"releases/changelog/#10-alpha02","text":"#19 \u2013 Fixed : Do not allow setting Node.integrationPoint on non-root nodes #23 \u2013 Fixed : Integration point attached twice crash when using live literals #14 \u2013 Fixed : Transition interruptions bug #23 \u2013 Added : Unit test support #26 \u2013 Added : Publish snapshot versions #9 \u2013 Migrated : app-tree-utils into this repository 19 Jul 2022","title":"1.0-alpha02"},{"location":"releases/changelog/#10-alpha01","text":"Initial release 4 Jul 2022","title":"1.0-alpha01"},{"location":"releases/downloads/","text":"Downloads \u00b6 Latest version \u00b6 Repository \u00b6 repositories { mavenCentral () } Core dependencies \u00b6 dependencies { // Core implementation \"com.bumble.appyx:core:$version\" // Test rules and utility classes for testing on Android debugImplementation \"com.bumble.appyx:testing-ui-activity:$version\" androidTestImplementation \"com.bumble.appyx:testing-ui:$version\" // Utility classes for unit testing testImplementation \"com.bumble.appyx:testing-unit-common:$version\" // Test rules and utility classes for unit testing using JUnit4 testImplementation \"com.bumble.appyx:testing-junit4:$version\" // Test extensions and utility classes for unit testing using JUnit5 testImplementation \"com.bumble.appyx:testing-junit5:$version\" } Interop with other libraries \u00b6 dependencies { // Optional support for RxJava 2/3 implementation \"com.bumble.appyx:interop-rx2:$version\" implementation \"com.bumble.appyx:interop-rx3:$version\" // Optional interoperability layer between Appyx and badoo/RIBs // You have to add https://jitpack.io repository to use it because badoo/RIBs is hosted there implementation \"com.bumble.appyx:interop-ribs:$version\" } Snapshot \u00b6 Snapshot version is available for all modules, use the provided repository url and 1-SNAPSHOT version. repositories { maven { url = 'https://s01.oss.sonatype.org/content/repositories/snapshots/' } } dependencies { implementation \"com.bumble.appyx:core:v1-SNAPSHOT\" }","title":"Downloads"},{"location":"releases/downloads/#downloads","text":"","title":"Downloads"},{"location":"releases/downloads/#latest-version","text":"","title":"Latest version"},{"location":"releases/downloads/#repository","text":"repositories { mavenCentral () }","title":"Repository"},{"location":"releases/downloads/#core-dependencies","text":"dependencies { // Core implementation \"com.bumble.appyx:core:$version\" // Test rules and utility classes for testing on Android debugImplementation \"com.bumble.appyx:testing-ui-activity:$version\" androidTestImplementation \"com.bumble.appyx:testing-ui:$version\" // Utility classes for unit testing testImplementation \"com.bumble.appyx:testing-unit-common:$version\" // Test rules and utility classes for unit testing using JUnit4 testImplementation \"com.bumble.appyx:testing-junit4:$version\" // Test extensions and utility classes for unit testing using JUnit5 testImplementation \"com.bumble.appyx:testing-junit5:$version\" }","title":"Core dependencies"},{"location":"releases/downloads/#interop-with-other-libraries","text":"dependencies { // Optional support for RxJava 2/3 implementation \"com.bumble.appyx:interop-rx2:$version\" implementation \"com.bumble.appyx:interop-rx3:$version\" // Optional interoperability layer between Appyx and badoo/RIBs // You have to add https://jitpack.io repository to use it because badoo/RIBs is hosted there implementation \"com.bumble.appyx:interop-ribs:$version\" }","title":"Interop with other libraries"},{"location":"releases/downloads/#snapshot","text":"Snapshot version is available for all modules, use the provided repository url and 1-SNAPSHOT version. repositories { maven { url = 'https://s01.oss.sonatype.org/content/repositories/snapshots/' } } dependencies { implementation \"com.bumble.appyx:core:v1-SNAPSHOT\" }","title":"Snapshot"},{"location":"ui/children-view/","text":"Adding children to the view \u00b6 Navigation models define only the abstract model, not how that model will look on the screen. This section describes different ways of adding children (navigation targets) to the composition. All the below mentioned composables should be added to the View of the parent node. Children \u00b6 Renders all visible children of a NavModel. This is the simplest and most common case. @Composable override fun View ( modifier : Modifier ) { Children ( modifier = Modifier , // optional navModel = TODO (), transitionHandler = TODO () // optional ) } When rendering children you can have access to TransitionDescriptor which provides the following information: @Immutable data class TransitionDescriptor < NavTarget , out State > ( val params : TransitionParams , val operation : Operation < NavTarget , out State > , val element : NavTarget , val fromState : State , val toState : State ) Additionally, you can supply custom modifier to a child Node . In this example, we're supplying different Modifier to a child Node depending on the NavTarget : @Composable override fun View ( modifier : Modifier ) { Children ( modifier = Modifier , // optional navModel = TODO (), transitionHandler = TODO () // optional ) { children < NavTarget > { child , descriptor -> child ( modifier = Modifier . background ( color = getBackgroundColor ( descriptor . element ) ) ) } } } Child \u00b6 Renders a single child associated to a NavElement . Useful if you want to define different child placements in the layout individually. @Composable override fun View ( modifier : Modifier ) { Child ( navElement = element , transitionHandler = TODO () ) { child , _ -> // TODO wrap in your own composables child () } } Lazy lists / grids \u00b6 @Composable override fun View ( modifier : Modifier ) { // TODO grab all visible children from the navModel manually val children by navModel . visibleChildrenAsState () GridExample ( children ) } @Composable private fun GridExample ( elements : List < NavElement < NavTarget , out Any? >> ) { LazyVerticalGrid ( columns = Fixed ( 2 ), modifier = Modifier . fillMaxSize (), contentPadding = PaddingValues ( horizontal = 16. dp ), ) { items ( elements ) { element -> // TODO use Child composable to render them individually inside the list / grid Child ( navElement = element ) } } }","title":"Children"},{"location":"ui/children-view/#adding-children-to-the-view","text":"Navigation models define only the abstract model, not how that model will look on the screen. This section describes different ways of adding children (navigation targets) to the composition. All the below mentioned composables should be added to the View of the parent node.","title":"Adding children to the view"},{"location":"ui/children-view/#children","text":"Renders all visible children of a NavModel. This is the simplest and most common case. @Composable override fun View ( modifier : Modifier ) { Children ( modifier = Modifier , // optional navModel = TODO (), transitionHandler = TODO () // optional ) } When rendering children you can have access to TransitionDescriptor which provides the following information: @Immutable data class TransitionDescriptor < NavTarget , out State > ( val params : TransitionParams , val operation : Operation < NavTarget , out State > , val element : NavTarget , val fromState : State , val toState : State ) Additionally, you can supply custom modifier to a child Node . In this example, we're supplying different Modifier to a child Node depending on the NavTarget : @Composable override fun View ( modifier : Modifier ) { Children ( modifier = Modifier , // optional navModel = TODO (), transitionHandler = TODO () // optional ) { children < NavTarget > { child , descriptor -> child ( modifier = Modifier . background ( color = getBackgroundColor ( descriptor . element ) ) ) } } }","title":"Children"},{"location":"ui/children-view/#child","text":"Renders a single child associated to a NavElement . Useful if you want to define different child placements in the layout individually. @Composable override fun View ( modifier : Modifier ) { Child ( navElement = element , transitionHandler = TODO () ) { child , _ -> // TODO wrap in your own composables child () } }","title":"Child"},{"location":"ui/children-view/#lazy-lists-grids","text":"@Composable override fun View ( modifier : Modifier ) { // TODO grab all visible children from the navModel manually val children by navModel . visibleChildrenAsState () GridExample ( children ) } @Composable private fun GridExample ( elements : List < NavElement < NavTarget , out Any? >> ) { LazyVerticalGrid ( columns = Fixed ( 2 ), modifier = Modifier . fillMaxSize (), contentPadding = PaddingValues ( horizontal = 16. dp ), ) { items ( elements ) { element -> // TODO use Child composable to render them individually inside the list / grid Child ( navElement = element ) } } }","title":"Lazy lists / grids"},{"location":"ui/transitions/","text":"Transitions \u00b6 You can have arbitrary visualisations and transitions for any NavModel . For example, all of these are different representations of the same Back stack : Below you can find the different options how to visualise NavModel state changes. No transitions \u00b6 Using the provided Child-related composables you'll see no transitions as a default \u2013 UI changes resulting from the NavModel's state update will be rendered instantly. Jetpack Compose default animations \u00b6 You can use standard Compose animations for embedded child Nodes in the view, e.g. AnimatedVisibility : var visibility by remember { mutableStateOf ( true ) } Child ( navElement ) { child , _ -> AnimatedVisibility ( visible = visibility ) { child () } } Appyx transition handlers \u00b6 All the child composables provided by Appyx accept an optional transitionHandler argument too: You can use the provided ones as they're a one-liner to add \u2013 you can check the individual NavModels for the ones they come shipped with. You can also implement your own. The benefit of using transition handlers is you can represent any custom state of elements defined by your NavModel with Compose Modifiers . The example below is taken from custom navigation models . It matches custom transition states to different scaling values, and returns a scale Modifier . class FooTransitionHandler < T > ( private val transitionSpec : TransitionSpec < Foo . State , Float > = { spring () } ) : ModifierTransitionHandler < T , Foo . State > () { // TODO define a Modifier depending on the state. // Here we'll just mutate scaling: override fun createModifier ( modifier : Modifier , transition : Transition < Foo . State > , descriptor : TransitionDescriptor < T , Foo . State > ): Modifier = modifier . composed { val scale = transition . animateFloat ( transitionSpec = transitionSpec , targetValueByState = { when ( it ) { Foo . State . CREATED -> 0f Foo . State . FOO -> 0.33f Foo . State . BAR -> 0.66f Foo . State . BAZ -> 1.0f Foo . State . DESTROYED -> 0f } }) scale ( scale . value ) } } // TODO remember to add: @Composable fun < T > rememberFooTransitionHandler ( transitionSpec : TransitionSpec < Foo . State , Float > = { spring () } ): ModifierTransitionHandler < T , Foo . State > = remember { FooTransitionHandler ( transitionSpec ) } More info \u00b6 You can find more complex examples in the implementations of other NavModels, such as the Promoter carousel You can find Codelabs tutorials that help you master custom transitions You can find Coding challenges related to custom transitions","title":"Transitions"},{"location":"ui/transitions/#transitions","text":"You can have arbitrary visualisations and transitions for any NavModel . For example, all of these are different representations of the same Back stack : Below you can find the different options how to visualise NavModel state changes.","title":"Transitions"},{"location":"ui/transitions/#no-transitions","text":"Using the provided Child-related composables you'll see no transitions as a default \u2013 UI changes resulting from the NavModel's state update will be rendered instantly.","title":"No transitions"},{"location":"ui/transitions/#jetpack-compose-default-animations","text":"You can use standard Compose animations for embedded child Nodes in the view, e.g. AnimatedVisibility : var visibility by remember { mutableStateOf ( true ) } Child ( navElement ) { child , _ -> AnimatedVisibility ( visible = visibility ) { child () } }","title":"Jetpack Compose default animations"},{"location":"ui/transitions/#appyx-transition-handlers","text":"All the child composables provided by Appyx accept an optional transitionHandler argument too: You can use the provided ones as they're a one-liner to add \u2013 you can check the individual NavModels for the ones they come shipped with. You can also implement your own. The benefit of using transition handlers is you can represent any custom state of elements defined by your NavModel with Compose Modifiers . The example below is taken from custom navigation models . It matches custom transition states to different scaling values, and returns a scale Modifier . class FooTransitionHandler < T > ( private val transitionSpec : TransitionSpec < Foo . State , Float > = { spring () } ) : ModifierTransitionHandler < T , Foo . State > () { // TODO define a Modifier depending on the state. // Here we'll just mutate scaling: override fun createModifier ( modifier : Modifier , transition : Transition < Foo . State > , descriptor : TransitionDescriptor < T , Foo . State > ): Modifier = modifier . composed { val scale = transition . animateFloat ( transitionSpec = transitionSpec , targetValueByState = { when ( it ) { Foo . State . CREATED -> 0f Foo . State . FOO -> 0.33f Foo . State . BAR -> 0.66f Foo . State . BAZ -> 1.0f Foo . State . DESTROYED -> 0f } }) scale ( scale . value ) } } // TODO remember to add: @Composable fun < T > rememberFooTransitionHandler ( transitionSpec : TransitionSpec < Foo . State , Float > = { spring () } ): ModifierTransitionHandler < T , Foo . State > = remember { FooTransitionHandler ( transitionSpec ) }","title":"Appyx transition handlers"},{"location":"ui/transitions/#more-info","text":"You can find more complex examples in the implementations of other NavModels, such as the Promoter carousel You can find Codelabs tutorials that help you master custom transitions You can find Coding challenges related to custom transitions","title":"More info"}]}